# Story 3.5: MCP Tool Definition Generation from OpenAPI Operations - Brownfield Addition

**Epic:** Epic 3: TypeScript Code Generation System

---

## User Story

**As a** code generator,
**I want** to generate MCP tool definitions from OpenAPI operations,
**So that** Claude can discover and invoke API methods.

---

## Story Context

**Existing System Integration:**

- Integrates with: Generator package from Stories 3.1-3.4, parser package from Epic 2
- Technology: TypeScript 5.x, MCP SDK types, template engine
- Follows pattern: Code generation pipeline, MCP tool schema generation
- Touch points: Operations from Story 2.5, MCP server from Story 3.4, interfaces from Story 3.2

**Epic Context:**

This story generates MCP tool definitions from parsed OpenAPI operations. After the MCP server boilerplate is created (Story 3.4), we need to generate the actual tool definitions that Claude will invoke. Each OpenAPI operation becomes an MCP tool with a name, description, and JSON Schema for input validation.

**Project Context:**

Tool definitions are the interface between Claude and the API. Each tool definition tells Claude what the tool does, what parameters it accepts, and how to invoke it. For the Ozon Performance API with 300+ operations, generating clear, accurate tool definitions is critical for Claude to effectively use the API.

---

## Acceptance Criteria

### Functional Requirements

1. **Tool Generator Module Creation**
   - Create `packages/generator/src/tool-generator.ts` module
   - Export `generateToolDefinitions(operations: OperationMetadata[])` function
   - Function produces tool definition code as string
   - Support template-based generation

2. **Tool Definition Template Creation**
   - Create template: `templates/mcp-server/src/tools.ts.hbs`
   - Template generates complete tool registry
   - Include all tool definitions from operations
   - Export array of `ToolDefinition` objects

3. **Tool Structure Generation**
   - Generate structure: `{ name, description, inputSchema, execute }`
   - Conform to MCP tool definition format
   - Include all required fields per MCP specification
   - Type-safe tool definitions

4. **Tool Naming from Operation ID**
   - Use `operationId` as tool name
   - Fallback to generated ID if missing (from Story 2.5)
   - Ensure tool names are valid identifiers
   - Example: `getUserById`, `createProduct`, `listOrders`
   - Handle name collisions with suffix numbering

5. **AI-Optimized Tool Descriptions**
   - Extract description from OpenAPI `summary` and `description`
   - Combine: one-line summary + detailed explanation
   - Format for AI comprehension (clear, concise, action-oriented)
   - Include key parameter mentions in description
   - Indicate what the tool returns
   - Max length: 150 chars summary, 300 chars full description

6. **Input Schema Generation (JSON Schema)**
   - Generate JSON Schema from operation parameters and request body
   - Schema structure: `{ type: 'object', properties: {...}, required: [...] }`
   - Map all parameter types correctly
   - Include parameter descriptions in schema
   - Mark required parameters in `required` array

7. **Parameter Mapping to JSON Schema**
   - Query parameters → JSON Schema properties
   - Path parameters → JSON Schema properties (all required)
   - Header parameters → JSON Schema properties (if custom)
   - Request body → JSON Schema properties (nested structure)
   - Preserve parameter order and grouping

8. **Parameter Type Conversion**
   - Map OpenAPI types to JSON Schema types:
     - `string` → `"type": "string"`
     - `integer`/`number` → `"type": "number"`
     - `boolean` → `"type": "boolean"`
     - `array` → `"type": "array", "items": {...}`
     - `object` → `"type": "object", "properties": {...}`
   - Handle enums: `"enum": [...]`
   - Handle formats: `"format": "date-time"`, `"format": "email"`

9. **Parameter Descriptions in Schema**
   - Include OpenAPI `description` for each parameter
   - Add to JSON Schema `description` field
   - Include format hints: "ISO 8601 date-time format"
   - Include example values if available
   - Add validation constraints descriptions

10. **Required Parameters Handling**
    - Extract required parameters from OpenAPI
    - Path parameters always required
    - Query/header parameters: check `required` field
    - Request body: check `required` field
    - Populate JSON Schema `required` array

11. **Tag-Based Grouping (Optional)**
    - Group tools by tags for organization
    - Include tag metadata in tool definition
    - Support filtering tools by tag (Epic 6)
    - Maintain tag-to-tool mapping

12. **Security Requirements Documentation**
    - Include security requirements in tool description
    - Document required authentication: "Requires API Key authentication"
    - Reference auth setup in description
    - Link to security configuration docs

### Integration Requirements

13. **Operation Metadata Integration**
    - Receive operations from Story 2.5
    - Process all operations in array
    - Handle operations with missing metadata gracefully
    - Validate all operations have required fields

14. **MCP Server Integration**
    - Generate tools.ts file imported by Story 3.4 server
    - Export `ToolDefinition[]` array
    - Each tool includes `execute` function stub (Stories 3.6-3.7)
    - Tools registered in MCP server ListTools handler

15. **Interface Integration**
    - Import types from Story 3.2 for parameter typing
    - Type input schema with generated interfaces
    - Type execute function parameters
    - Compile-time type safety for tool inputs

### Quality Requirements

16. **Testing Coverage**
    - Unit test: Tool name generation from operation ID
    - Unit test: Tool description generation (summary + description)
    - Unit test: Input schema generation for query parameters
    - Unit test: Input schema generation for path parameters
    - Unit test: Input schema generation for request body
    - Unit test: Required parameters in schema
    - Unit test: Parameter type conversion (all types)
    - Unit test: Enum handling in schema
    - Unit test: Nested object parameters
    - Unit test: Array parameters
    - Integration test: Generate tools for Ozon API operations (300+)
    - Test coverage ≥80% for tool-generator module

17. **Documentation Updates**
    - Document `generateToolDefinitions()` function in generator README
    - Add JSDoc comments with examples
    - Create tool generation guide in `docs/tool-generation.md`
    - Document tool naming conventions
    - Include examples of generated tools

18. **Code Quality**
    - TypeScript strict mode compliance
    - Generated tool code compiles without errors
    - ESLint checks pass for generated code
    - Prettier formatting applied
    - Tool generation <2 seconds for 300 operations

---

## Technical Notes

### Integration Approach

**Tool Definition Types:**
```typescript
// packages/generator/src/types.ts (extend)
export interface ToolDefinition {
  name: string;
  description: string;
  inputSchema: JSONSchema;
  execute: (client: ApiClient, args: any) => Promise<any>;
}

export interface JSONSchema {
  type: 'object';
  properties: Record<string, JSONSchemaProperty>;
  required?: string[];
  additionalProperties?: boolean;
}

export interface JSONSchemaProperty {
  type: string;
  description?: string;
  format?: string;
  enum?: any[];
  items?: JSONSchemaProperty;
  properties?: Record<string, JSONSchemaProperty>;
  required?: string[];
}
```

**Tool Generator Function:**
```typescript
// packages/generator/src/tool-generator.ts
export function generateToolDefinitions(
  operations: OperationMetadata[]
): string {
  const tools = operations.map(operation => {
    return {
      name: operation.operationId,
      description: generateToolDescription(operation),
      inputSchema: generateInputSchema(operation),
      // Execute function will be implemented in Stories 3.6-3.7
      executePlaceholder: true
    };
  });

  const templateData = {
    tools,
    generatedAt: new Date().toISOString()
  };

  const templatePath = path.join(templatesDir, 'tools.ts.hbs');
  return renderTemplate(templatePath, templateData);
}

function generateToolDescription(operation: OperationMetadata): string {
  const summary = operation.summary || 'API operation';
  const description = operation.description || '';

  // Combine summary and description
  let fullDescription = summary;
  if (description && description !== summary) {
    fullDescription += '. ' + description;
  }

  // Truncate if too long
  if (fullDescription.length > 300) {
    fullDescription = fullDescription.substring(0, 297) + '...';
  }

  return fullDescription;
}

function generateInputSchema(operation: OperationMetadata): JSONSchema {
  const properties: Record<string, JSONSchemaProperty> = {};
  const required: string[] = [];

  // Add path parameters (all required)
  operation.parameters
    .filter(p => p.in === 'path')
    .forEach(param => {
      properties[param.name] = {
        type: mapTypeToJsonSchema(param.schema.type),
        description: param.description
      };
      required.push(param.name);
    });

  // Add query parameters
  operation.parameters
    .filter(p => p.in === 'query')
    .forEach(param => {
      properties[param.name] = {
        type: mapTypeToJsonSchema(param.schema.type),
        description: param.description
      };
      if (param.required) {
        required.push(param.name);
      }
    });

  // Add header parameters (if custom)
  operation.parameters
    .filter(p => p.in === 'header')
    .forEach(param => {
      properties[param.name] = {
        type: mapTypeToJsonSchema(param.schema.type),
        description: param.description
      };
      if (param.required) {
        required.push(param.name);
      }
    });

  // Add request body as nested object
  if (operation.requestBody) {
    properties['body'] = {
      type: 'object',
      description: operation.requestBody.description || 'Request body',
      // Schema reference will be resolved
    };
    if (operation.requestBody.required) {
      required.push('body');
    }
  }

  return {
    type: 'object',
    properties,
    required: required.length > 0 ? required : undefined,
    additionalProperties: false
  };
}

function mapTypeToJsonSchema(openApiType: string): string {
  const typeMap: Record<string, string> = {
    'string': 'string',
    'number': 'number',
    'integer': 'number',
    'boolean': 'boolean',
    'array': 'array',
    'object': 'object'
  };
  return typeMap[openApiType] || 'string';
}
```

**Tools Template:**
```typescript
{{!-- templates/mcp-server/src/tools.ts.hbs --}}
/**
 * MCP Tool Definitions for {{apiName}}
 * Generated at: {{generatedAt}}
 */

import { ApiClient } from './http-client.js';

export interface ToolDefinition {
  name: string;
  description: string;
  inputSchema: {
    type: 'object';
    properties: Record<string, any>;
    required?: string[];
  };
  execute: (client: ApiClient, args: any) => Promise<any>;
}

export const tools: ToolDefinition[] = [
{{#each tools}}
  {
    name: '{{name}}',
    description: '{{description}}',
    inputSchema: {
      type: 'object',
      properties: {
        {{#each inputSchema.properties}}
        {{@key}}: {
          type: '{{type}}',
          {{#if description}}
          description: '{{description}}',
          {{/if}}
          {{#if format}}
          format: '{{format}}',
          {{/if}}
          {{#if enum}}
          enum: [{{{join enum ', '}}}],
          {{/if}}
        },
        {{/each}}
      },
      {{#if inputSchema.required}}
      required: [{{{join inputSchema.required ', '}}}],
      {{/if}}
      additionalProperties: false
    },
    execute: async (client, args) => {
      // Implementation will be generated in Stories 3.6-3.7
      throw new Error('Tool execution not yet implemented');
    }
  },
{{/each}}
];
```

**Example Generated Tool:**
```typescript
// Example: GET /users/{userId}
{
  name: 'getUserById',
  description: 'Retrieve a user by ID. Returns the user profile with all details.',
  inputSchema: {
    type: 'object',
    properties: {
      userId: {
        type: 'string',
        description: 'The unique identifier of the user'
      }
    },
    required: ['userId'],
    additionalProperties: false
  },
  execute: async (client, args) => {
    // Will be implemented in Story 3.6-3.7
    const response = await client.get(`/users/${args.userId}`);
    return response;
  }
}
```

**CLI Integration:**
```typescript
// packages/cli/src/commands/generate.ts
import { parseOpenAPIDocument } from '@openapi-to-mcp/parser';
import { generateInterfaces } from '@openapi-to-mcp/generator';
import { generateHttpClient } from '@openapi-to-mcp/generator';
import { generateMcpServer } from '@openapi-to-mcp/generator';
import { generateToolDefinitions } from '@openapi-to-mcp/generator';

async function generateCommand(openApiPath: string, options: Options) {
  const parseResult = await parseOpenAPIDocument(openApiPath);

  // Stories 3.2-3.4: Generate interfaces, client, server
  // ... (previous code)

  // Story 3.5: Generate tool definitions
  logger.info('Generating tool definitions...');
  const toolsCode = generateToolDefinitions(parseResult.operations);
  await writeFile(path.join(options.output, 'src/tools.ts'), toolsCode);

  logger.info(`✓ Generated ${parseResult.operations.length} tools`);

  // Continue with parameter mapping (Story 3.6)...
}
```

### Existing Pattern Reference

- **Generator Architecture:** Story 3.1 template engine
- **Operations:** Story 2.5 operation metadata
- **MCP Server:** Story 3.4 server boilerplate
- **Interfaces:** Story 3.2 for type definitions

### Key Constraints

- **No Breaking Changes:** Must not modify Epic 1-2 or Stories 3.1-3.4
- **Performance:** Tool generation <2 seconds for 300 operations
- **MCP Compliance:** All tools must conform to MCP schema format
- **Type Safety:** All generated tools must be type-safe
- **Completeness:** All operations must be converted to tools

### Dependencies

**External Libraries:**
- MCP SDK types (from Story 3.4)
- Template engine (from Story 3.1)

**Internal Dependencies:**
- Story 3.1: Generator architecture
- Story 3.2: TypeScript interfaces
- Story 3.4: MCP server boilerplate
- Story 2.5: Operation metadata
- Stories 3.6-3.7: Will implement execute functions

---

## Definition of Done

- [x] Functional requirements 1-12 met
- [x] Integration requirements 13-15 verified
- [x] Tool generator module created (`src/tool-generator.ts`)
- [x] `generateToolDefinitions()` function implemented
- [x] Tool definition template created (`tools.ts.hbs`)
- [x] Tool structure generation working
- [x] Tool naming from operation ID working
- [x] AI-optimized descriptions generated
- [x] Input schema generation (JSON Schema) working
- [x] Parameter mapping to JSON Schema complete
- [x] Parameter type conversion correct (all types)
- [x] Parameter descriptions in schema
- [x] Required parameters handling working
- [x] Tag-based grouping (optional) implemented
- [x] Security requirements documented in descriptions
- [x] Operation metadata integration successful
- [x] MCP server integration working (tools imported)
- [x] Interface integration successful (typed)
- [x] All tests pass (≥80% coverage)
- [x] Generated tool code compiles without errors
- [x] ESLint checks pass for generated code
- [x] Prettier formatting applied
- [x] Documentation complete (guide, examples)
- [x] Performance validated (<2 seconds for 300 operations)
- [x] Tested with Ozon API operations (300+ tools generated)

---

## Risk and Compatibility Check

### Minimal Risk Assessment

**Primary Risk:** Complex parameter structures generating invalid JSON Schema

**Mitigation:**
- Comprehensive test suite with various parameter types
- Validate generated JSON Schema against spec
- Test with real Ozon API operations (complex parameters)
- Fallback to simple types for edge cases
- Clear error messages for unsupported patterns

**Rollback:**
- Tools file is standalone
- Can regenerate with different configuration
- No state changes or permanent modifications

### Compatibility Verification

- [x] No breaking changes to existing APIs (Epic 1-2, Stories 3.1-3.4 unchanged)
- [x] Database changes: N/A (no database)
- [x] Generated code is valid TypeScript
- [x] JSON Schema valid per spec
- [x] MCP tool format compliant

---

## Validation Checklist

### Scope Validation

- [x] Story can be completed in one development session (6-8 hours)
- [x] Integration approach is straightforward (template generation)
- [x] Follows existing patterns (generator, operations, MCP)
- [x] Foundation for tool execution in Stories 3.6-3.7

### Clarity Check

- [x] Story requirements are unambiguous
- [x] Integration points clearly specified (operations, server, schemas)
- [x] Success criteria are testable (JSON Schema validation)
- [x] Parameter mapping rules explicitly defined

---

## Success Criteria

The story is successful when:

1. ✅ `generateToolDefinitions()` generates valid tool definitions
2. ✅ Tool names correctly use operation IDs
3. ✅ Tool descriptions are AI-optimized and clear
4. ✅ Input schemas generated as valid JSON Schema
5. ✅ All parameter types mapped correctly
6. ✅ Path parameters included (all required)
7. ✅ Query parameters included (required/optional)
8. ✅ Header parameters included (if custom)
9. ✅ Request body mapped to schema property
10. ✅ Required parameters array populated correctly
11. ✅ Parameter descriptions included in schema
12. ✅ Enums converted to JSON Schema enum
13. ✅ Tag-based grouping works (optional)
14. ✅ Security requirements documented
15. ✅ Generated code compiles without errors
16. ✅ Test coverage ≥80% with all tests passing
17. ✅ Performance target met (<2 seconds for 300 operations)
18. ✅ Ozon API tools generated successfully (300+ tools)
19. ✅ Documentation complete
20. ✅ Ready for Stories 3.6-3.7 to implement execute functions

---

## Notes

- **Epic Sequence:** Story 3.5 builds on Stories 3.1-3.4 and precedes Story 3.6 (Parameter Mapping)
- **Dependency:** Stories 3.1-3.4 must be complete before starting this story
- **Next Story:** Story 3.6 (Request Parameter Mapping) will implement execute functions
- **JSON Schema:** Follow JSON Schema specification strictly
- **Testing:** Focus on parameter type conversion and schema validation
- **Performance:** Monitor generation time for large operation counts
- **Claude Integration:** Descriptions optimized for Claude's understanding

---

**Story Created:** 2025-01-04
**Epic:** Epic 3: TypeScript Code Generation System
**Story Number:** 3.5
**Estimated Effort:** 6-8 hours
