# Story 3.3: HTTP Client Base Implementation with Axios - Brownfield Addition

**Epic:** Epic 3: TypeScript Code Generation System

---

## User Story

**As a** generated MCP server,
**I want** an HTTP client configured for making API requests,
**So that** I can communicate with the target API.

---

## Story Context

**Existing System Integration:**

- Integrates with: Generator package from Stories 3.1-3.2, parser package from Epic 2
- Technology: TypeScript 5.x, Axios HTTP library, template engine
- Follows pattern: Code generation pipeline, template-based generation
- Touch points: Interfaces from Story 3.2, server URLs from Story 2.8, auth from Epic 4

**Epic Context:**

This story generates the HTTP client that the MCP server uses to communicate with the target API. After TypeScript interfaces are generated (Story 3.2), we need an HTTP client configured with the API's base URL, timeout settings, and request/response interceptors. The client will be used by all MCP tool implementations.

**Project Context:**

The HTTP client is the communication layer between the MCP server and the target API. It handles request construction, response processing, error handling, and retry logic. For the Ozon Performance API, the client must handle 300+ different API calls reliably with proper error handling and timeout management.

---

## Acceptance Criteria

### Functional Requirements

1. **HTTP Client Template Creation**
   - Create template: `templates/mcp-server/src/http-client.ts.hbs`
   - Template generates complete HTTP client class
   - Include all necessary Axios configuration
   - Generate with TypeScript types from Story 3.2

2. **Axios Integration**
   - Use Axios as HTTP library (industry standard, TypeScript support)
   - Install `axios@^1.6.0` as dependency in generated project
   - Import Axios types for TypeScript support
   - Configure Axios instance with proper settings

3. **Base Client Class Structure**
   - Create `ApiClient` class with configurable options
   - Constructor accepts: `{ baseURL, timeout, headers, auth }`
   - Initialize Axios instance with configuration
   - Expose typed request methods: `get<T>()`, `post<T>()`, `put<T>()`, `patch<T>()`, `delete<T>()`
   - Support method chaining for configuration

4. **Client Initialization**
   - Accept config object: `ClientConfig` interface
   - Required: `baseURL` (from server extraction Story 2.8)
   - Optional: `timeout`, `headers`, `auth` (from Epic 4)
   - Validate configuration before creating instance
   - Provide sensible defaults for optional fields

5. **Request Interceptor Support**
   - Configure Axios request interceptor
   - Pre-process requests: add auth headers, log, transform data
   - Support multiple interceptors (auth, logging, custom)
   - Execute interceptors in registration order
   - Handle interceptor errors gracefully

6. **Response Interceptor Support**
   - Configure Axios response interceptor
   - Post-process responses: extract data, log, transform
   - Handle successful responses (2xx status codes)
   - Pass through to error handling for non-2xx
   - Support response transformation

7. **Error Handling**
   - Wrap Axios errors in custom `ApiError` class
   - Include: status code, message, response data, request info
   - Preserve error stack trace for debugging
   - Differentiate: network errors vs API errors vs timeout errors
   - Provide error context for troubleshooting

8. **Timeout Configuration**
   - Default timeout: 30 seconds (30000ms)
   - Configurable via constructor or environment variable
   - Apply to all requests unless overridden per-request
   - Separate connect timeout and response timeout (if supported)
   - Throw `TimeoutError` on timeout with clear message

9. **Retry Logic with Exponential Backoff**
   - Retry on 5xx server errors (configurable)
   - Retry on network errors (ECONNRESET, ETIMEDOUT)
   - Exponential backoff: 1s, 2s, 4s, 8s, 16s
   - Configurable retry count (default: 3 retries)
   - Configurable retry conditions and backoff strategy
   - Max retry delay cap (default: 30s)

10. **Request/Response Logging**
    - Log all requests in debug mode
    - Include: method, URL, headers (sanitized), body (truncated)
    - Log all responses in debug mode
    - Include: status code, headers, body (truncated)
    - Never log sensitive data (auth tokens, API keys)
    - Configurable log level via environment variable

11. **Type-Safe Request Methods**
    - Generic methods: `get<T>(url, config?)`, `post<T>(url, data?, config?)`
    - Return type: `Promise<T>` (typed response data)
    - Automatic JSON serialization/deserialization
    - Support for query parameters, headers, request body
    - TypeScript intellisense for all methods

12. **Base URL Handling**
    - Resolve relative paths against base URL
    - Handle trailing slashes correctly (remove duplicates)
    - Merge operation paths with base URL
    - Support URL parameters substitution
    - Validate base URL format

### Integration Requirements

13. **Server URL Integration**
    - Use server URLs from Story 2.8 extraction
    - Select default server (first in array)
    - Support runtime server switching via config
    - Handle server URL variables with defaults

14. **Interface Integration**
    - Import types from Story 3.2 generated interfaces
    - Type request bodies with generated interfaces
    - Type response data with generated interfaces
    - Compile-time type checking for all requests

15. **Template Data Model**
    - Receive server configuration from parser
    - Receive timeout settings from options
    - Include retry configuration
    - Template variables: `baseURL`, `timeout`, `retryCount`

### Quality Requirements

16. **Testing Coverage**
    - Unit test: Client initialization with config
    - Unit test: GET request with typed response
    - Unit test: POST request with body
    - Unit test: PUT, PATCH, DELETE requests
    - Unit test: Error handling (4xx, 5xx, network errors)
    - Unit test: Timeout handling
    - Unit test: Retry logic with exponential backoff
    - Unit test: Request/response interceptors
    - Unit test: Base URL resolution
    - Unit test: Logging (debug mode)
    - Integration test: Generated client with mocked API
    - Test coverage â‰¥80% for http-client template

17. **Documentation Updates**
    - Document HTTP client in generated README
    - Include configuration examples
    - Document retry logic and error handling
    - Add troubleshooting section for common issues
    - Include environment variable reference

18. **Code Quality**
    - TypeScript strict mode compliance
    - Generated client code compiles without errors
    - ESLint checks pass for generated code
    - Prettier formatting applied
    - Client initialization <50ms

---

## Technical Notes

### Integration Approach

**HTTP Client Template:**
```typescript
{{!-- templates/mcp-server/src/http-client.ts.hbs --}}
/**
 * HTTP Client for {{apiName}} API
 * Base URL: {{primaryServer.baseURL}}
 * Generated at: {{generatedAt}}
 */

import axios, { AxiosInstance, AxiosRequestConfig, AxiosError } from 'axios';

/**
 * Client configuration options
 */
export interface ClientConfig {
  baseURL: string;
  timeout?: number;
  headers?: Record<string, string>;
  retryCount?: number;
  retryDelay?: number;
  debug?: boolean;
}

/**
 * API Error with additional context
 */
export class ApiError extends Error {
  constructor(
    message: string,
    public statusCode?: number,
    public response?: any,
    public request?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

/**
 * HTTP Client for API communication
 */
export class ApiClient {
  private client: AxiosInstance;
  private config: Required<ClientConfig>;

  constructor(config: ClientConfig) {
    this.config = {
      baseURL: config.baseURL || '{{primaryServer.baseURL}}',
      timeout: config.timeout || 30000,
      headers: config.headers || {},
      retryCount: config.retryCount || 3,
      retryDelay: config.retryDelay || 1000,
      debug: config.debug || false
    };

    this.client = axios.create({
      baseURL: this.config.baseURL,
      timeout: this.config.timeout,
      headers: this.config.headers
    });

    this.setupInterceptors();
  }

  /**
   * Setup request and response interceptors
   */
  private setupInterceptors(): void {
    // Request interceptor
    this.client.interceptors.request.use(
      (config) => {
        if (this.config.debug) {
          console.log(`[HTTP] ${config.method?.toUpperCase()} ${config.url}`);
        }
        return config;
      },
      (error) => {
        return Promise.reject(this.handleError(error));
      }
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response) => {
        if (this.config.debug) {
          console.log(`[HTTP] ${response.status} ${response.config.url}`);
        }
        return response;
      },
      async (error) => {
        return this.handleErrorWithRetry(error);
      }
    );
  }

  /**
   * Handle error with retry logic
   */
  private async handleErrorWithRetry(error: AxiosError, retryCount = 0): Promise<any> {
    const shouldRetry = this.shouldRetry(error, retryCount);

    if (shouldRetry) {
      const delay = this.calculateRetryDelay(retryCount);
      await this.sleep(delay);

      if (this.config.debug) {
        console.log(`[HTTP] Retry ${retryCount + 1}/${this.config.retryCount}`);
      }

      try {
        return await this.client.request(error.config!);
      } catch (retryError) {
        return this.handleErrorWithRetry(retryError as AxiosError, retryCount + 1);
      }
    }

    throw this.handleError(error);
  }

  /**
   * Determine if request should be retried
   */
  private shouldRetry(error: AxiosError, retryCount: number): boolean {
    if (retryCount >= this.config.retryCount) {
      return false;
    }

    // Retry on 5xx errors
    if (error.response?.status && error.response.status >= 500) {
      return true;
    }

    // Retry on network errors
    if (!error.response && error.code !== 'ECONNABORTED') {
      return true;
    }

    return false;
  }

  /**
   * Calculate retry delay with exponential backoff
   */
  private calculateRetryDelay(retryCount: number): number {
    const delay = this.config.retryDelay * Math.pow(2, retryCount);
    return Math.min(delay, 30000); // Cap at 30 seconds
  }

  /**
   * Sleep for specified milliseconds
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Handle and transform errors
   */
  private handleError(error: AxiosError): ApiError {
    if (error.response) {
      // Server responded with error status
      return new ApiError(
        error.message || 'API request failed',
        error.response.status,
        error.response.data,
        error.config
      );
    } else if (error.request) {
      // Request made but no response received
      return new ApiError(
        'No response from server',
        undefined,
        undefined,
        error.config
      );
    } else {
      // Error setting up request
      return new ApiError(error.message || 'Request setup failed');
    }
  }

  /**
   * Generic GET request
   */
  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.get<T>(url, config);
    return response.data;
  }

  /**
   * Generic POST request
   */
  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.post<T>(url, data, config);
    return response.data;
  }

  /**
   * Generic PUT request
   */
  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.put<T>(url, data, config);
    return response.data;
  }

  /**
   * Generic PATCH request
   */
  async patch<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.patch<T>(url, data, config);
    return response.data;
  }

  /**
   * Generic DELETE request
   */
  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.delete<T>(url, config);
    return response.data;
  }
}

// Export singleton instance with environment configuration
export const apiClient = new ApiClient({
  baseURL: process.env.API_BASE_URL || '{{primaryServer.baseURL}}',
  timeout: parseInt(process.env.API_TIMEOUT || '30000'),
  debug: process.env.DEBUG === 'true'
});
```

**Template Data Model:**
```typescript
// packages/generator/src/types.ts (extend)
export interface ServerTemplateData {
  baseURL: string;
  basePath: string;
  description?: string;
  environment?: string;
}

export interface HttpClientTemplateData {
  apiName: string;
  primaryServer: ServerTemplateData;
  defaultTimeout: number;
  defaultRetryCount: number;
  generatedAt: string;
}
```

**Generator Integration:**
```typescript
// packages/generator/src/http-client-generator.ts
export function generateHttpClient(
  servers: ServerExtractionResult,
  options: GenerationOptions
): string {
  const templateData: HttpClientTemplateData = {
    apiName: options.apiName,
    primaryServer: {
      baseURL: servers.defaultServer.baseURL,
      basePath: servers.defaultServer.basePath,
      description: servers.defaultServer.description,
      environment: servers.defaultServer.environment
    },
    defaultTimeout: 30000,
    defaultRetryCount: 3,
    generatedAt: new Date().toISOString()
  };

  const templatePath = path.join(templatesDir, 'http-client.ts.hbs');
  return renderTemplate(templatePath, templateData);
}
```

**CLI Integration:**
```typescript
// packages/cli/src/commands/generate.ts
import { parseOpenAPIDocument } from '@openapi-to-mcp/parser';
import { generateInterfaces } from '@openapi-to-mcp/generator';
import { generateHttpClient } from '@openapi-to-mcp/generator';

async function generateCommand(openApiPath: string, options: Options) {
  const parseResult = await parseOpenAPIDocument(openApiPath);

  // Story 3.2: Generate interfaces
  const interfaceResult = generateInterfaces(parseResult.schemas);
  await writeFile(path.join(options.output, 'src/types.ts'), interfaceResult.code);

  // Story 3.3: Generate HTTP client
  logger.info('Generating HTTP client...');
  const httpClientCode = generateHttpClient(parseResult.servers, {
    apiName: parseResult.metadata.apiName
  });
  await writeFile(path.join(options.output, 'src/http-client.ts'), httpClientCode);

  logger.info('âœ“ HTTP client generated');

  // Continue with MCP server generation (Story 3.4)...
}
```

### Existing Pattern Reference

- **Generator Architecture:** Story 3.1 template engine and formatting
- **Interfaces:** Story 3.2 generated TypeScript types
- **Server URLs:** Story 2.8 server extraction
- **Error Handling:** Story 1.7 error classes pattern

### Key Constraints

- **No Breaking Changes:** Must not modify Epic 1-2 or Stories 3.1-3.2
- **Performance:** Client initialization <50ms
- **Type Safety:** All methods fully typed with generics
- **Error Handling:** All errors wrapped in `ApiError`
- **Retry Logic:** Configurable and testable

### Dependencies

**External Libraries (for generated code):**
- `axios@^1.6.0` - HTTP client library
- `@types/node` - Node.js types for setTimeout, etc.

**Internal Dependencies:**
- Story 3.1: Generator architecture
- Story 3.2: TypeScript interfaces for request/response typing
- Story 2.8: Server URLs for base URL configuration
- Epic 4: Will add authentication interceptors

---

## Definition of Done

- [x] Functional requirements 1-12 met
- [x] Integration requirements 13-15 verified
- [x] HTTP client template created (`http-client.ts.hbs`)
- [x] Axios integration implemented
- [x] Base client class structure complete
- [x] Client initialization working with config
- [x] Request interceptor support implemented
- [x] Response interceptor support implemented
- [x] Error handling with `ApiError` class
- [x] Timeout configuration implemented
- [x] Retry logic with exponential backoff working
- [x] Request/response logging implemented (debug mode)
- [x] Type-safe request methods (`get<T>`, `post<T>`, etc.)
- [x] Base URL handling implemented
- [x] Server URL integration successful
- [x] Interface integration working (typed requests/responses)
- [x] Template data model implemented
- [x] All tests pass (â‰¥80% coverage)
- [x] Generated client code compiles without errors
- [x] ESLint checks pass for generated code
- [x] Prettier formatting applied
- [x] Documentation complete (README section, examples)
- [x] Performance validated (<50ms initialization)
- [x] Integration test with mocked API successful

---

## Risk and Compatibility Check

### Minimal Risk Assessment

**Primary Risk:** Retry logic or timeout handling causing unexpected behavior in production

**Mitigation:**
- Comprehensive test suite for retry scenarios
- Configurable retry count and delay
- Clear logging of retry attempts in debug mode
- Test with realistic network conditions
- Document retry behavior in generated README

**Rollback:**
- HTTP client is standalone file
- Can regenerate with different configuration
- No state changes or permanent modifications

### Compatibility Verification

- [x] No breaking changes to existing APIs (Epic 1-2, Stories 3.1-3.2 unchanged)
- [x] Database changes: N/A (no database)
- [x] Generated code is valid TypeScript
- [x] Axios version compatible with Node.js â‰¥18
- [x] Integration with Story 3.2 interfaces successful

---

## Validation Checklist

### Scope Validation

- [x] Story can be completed in one development session (6-8 hours)
- [x] Integration approach is straightforward (template generation)
- [x] Follows existing patterns (Story 3.1 generator, Story 3.2 types)
- [x] Foundation for MCP tool implementation in subsequent stories

### Clarity Check

- [x] Story requirements are unambiguous
- [x] Integration points clearly specified (server URLs, interfaces)
- [x] Success criteria are testable (compilation, runtime behavior)
- [x] Error handling and retry logic explicitly defined

---

## Success Criteria

The story is successful when:

1. âœ… HTTP client template generates valid TypeScript code
2. âœ… Axios integrated with proper TypeScript types
3. âœ… Client initialization works with configuration
4. âœ… Request/response interceptors functional
5. âœ… Error handling wraps all errors in `ApiError`
6. âœ… Timeout configuration working (default 30s)
7. âœ… Retry logic with exponential backoff implemented
8. âœ… Request/response logging works in debug mode
9. âœ… Type-safe methods provide full intellisense
10. âœ… Base URL resolution handles paths correctly
11. âœ… Server URL integration successful (uses Story 2.8 data)
12. âœ… Interface integration successful (uses Story 3.2 types)
13. âœ… Generated code compiles without errors
14. âœ… Test coverage â‰¥80% with all tests passing
15. âœ… Performance target met (<50ms initialization)
16. âœ… Documentation complete with examples
17. âœ… Ready for Stories 3.4+ to use HTTP client

---

## Notes

- **Epic Sequence:** Story 3.3 builds on Stories 3.1-3.2 and precedes Story 3.4 (MCP Server)
- **Dependency:** Stories 3.1-3.2 must be complete before starting this story
- **Next Story:** Story 3.4 (MCP Server Boilerplate) will use this HTTP client
- **Axios Version:** Use latest stable 1.x version for security and features
- **Testing:** Focus on error scenarios, retry logic, timeout handling
- **Performance:** Client should be lightweight and fast to initialize
- **Epic 4 Integration:** Authentication interceptors will be added in Epic 4

---

**Story Created:** 2025-01-04
**Epic:** Epic 3: TypeScript Code Generation System
**Story Number:** 3.3
**Estimated Effort:** 6-8 hours
