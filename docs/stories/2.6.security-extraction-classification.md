---
# Story Metadata
story_id: "2.6"
epic_id: "2"
title: "Security Scheme Extraction and Classification"
status: "Draft"
priority: "High"
estimated_effort: "4-6 hours"
created_date: "2025-01-04"
updated_date: "2025-01-04"
---

# Story 2.6: Security Scheme Extraction and Classification

**Epic:** Epic 2: OpenAPI Parsing & Validation Engine

---

## Status

**Current Status:** Draft
**Assigned To:** Unassigned
**Sprint:** Unassigned
**Last Updated:** 2025-01-04

---

## Story

**As a** code generator,
**I want** security schemes extracted and classified by authentication type,
**So that** I can generate appropriate authentication handlers.

### Story Context

**Existing System Integration:**
- Integrates with: Parser package (`packages/parser/`) from Stories 2.1-2.5
- Technology: TypeScript 5.x, OpenAPI security scheme processing
- Follows pattern: Parser pipeline (extract security after operations), data transformation
- Touch points: Fully resolved document from Story 2.3, operations from Story 2.5

**Epic Context:**
This story extracts and classifies authentication and authorization requirements from the OpenAPI document. Security schemes define how API requests must be authenticated (API Key, Bearer Token, OAuth2, etc.). After operations are extracted (Story 2.5), we need to understand which security schemes apply to each operation so Epic 4 can generate appropriate authentication handlers.

**Project Context:**
Security extraction enables the generated MCP server to authenticate API requests correctly. Each security scheme will be transformed into an authentication handler (Epic 4). The extracted security metadata tells the code generator what authentication code to generate and which environment variables users need to configure. For APIs like Ozon Performance API, this typically involves API Key or Bearer Token authentication.

---

## Acceptance Criteria

### AC1: Security Extractor Module Creation
**Given** the parser package structure from Stories 2.1-2.5,
**When** I create the security extractor module,
**Then** the module exports `extractSecuritySchemes()` function returning classified security scheme map.

### AC2: Security Scheme Classification
**Given** an OpenAPI document with security schemes,
**When** I extract security schemes,
**Then** each scheme is classified by authentication type (API Key, HTTP Bearer, HTTP Basic, OAuth2, OpenID Connect).

### AC3: API Key Scheme Metadata Extraction
**Given** an API Key security scheme,
**When** I extract metadata,
**Then** parameter name and location (header/query/cookie) are captured for code generation.

### AC4: HTTP Bearer Scheme Identification
**Given** an HTTP Bearer security scheme,
**When** I identify the scheme,
**Then** bearer format (e.g., JWT) is extracted and marked for Authorization header handling.

### AC5: HTTP Basic Scheme Identification
**Given** an HTTP Basic security scheme,
**When** I identify the scheme,
**Then** it's marked for username/password credentials and Authorization header handling.

### AC6: OAuth2 Scheme Handling
**Given** an OAuth2 security scheme,
**When** I extract OAuth2 metadata,
**Then** flows, scopes, authorization URL, and token URL are captured with manual implementation warning.

### AC7: OpenID Connect Scheme Handling
**Given** an OpenID Connect security scheme,
**When** I extract OIDC metadata,
**Then** provider URL is captured with manual implementation guidance.

### AC8: Security Requirement Extraction per Operation
**Given** an OpenAPI document with global and operation-level security,
**When** I extract security requirements,
**Then** effective security requirements are mapped to each operation with AND/OR logic.

### AC9: Multi-Scheme Detection
**Given** operations with multiple authentication methods,
**When** I detect multi-scheme requirements,
**Then** AND logic (multiple schemes required) and OR logic (alternative schemes) are distinguished.

### AC10: Global vs. Operation-Level Security
**Given** global security requirements and operation-level overrides,
**When** I merge security requirements,
**Then** operation-level security replaces global, empty array means no auth, and undefined inherits global.

### AC11: Unsupported Scheme Warnings
**Given** OAuth2 or OpenID Connect schemes,
**When** I classify schemes,
**Then** warnings are generated with manual implementation guidance.

### AC12: Operation Extraction Integration
**Given** extracted operations from Story 2.5,
**When** I extract security schemes,
**Then** security requirements are linked to operations by operation ID.

### AC13: Pipeline Integration
**Given** the complete parser pipeline,
**When** I integrate security extraction,
**Then** it receives fully resolved document and operations, returns security metadata.

### AC14: Output Validation
**Given** extracted security metadata,
**When** I validate output,
**Then** all scheme names are valid, all references exist, and metadata is complete for code generation.

### AC15: Testing Coverage
**Given** the security extractor module,
**When** I run tests,
**Then** ≥80% coverage with unit tests for all scheme types and integration tests with Ozon API.

### AC16: Documentation Updates
**Given** the security extraction functionality,
**When** I update documentation,
**Then** parser README, JSDoc comments, and security extraction guide are complete.

### AC17: Code Quality
**Given** the security extractor implementation,
**When** I run quality checks,
**Then** TypeScript strict mode, ESLint, Prettier pass, and extraction completes in <1 second.

---

## Tasks

### Task 1: Setup Security Extractor Module [AC1]
Create the security extractor module with core types and exports.

**Subtasks:**
1.1. Create `packages/parser/src/security-extractor.ts` file
1.2. Define `SecuritySchemeMap` interface for classified schemes
1.3. Define `ClassifiedSecurityScheme` interface with classification and metadata
1.4. Define `SecurityClassification` type union (api-key-header, http-bearer, etc.)
1.5. Define `SecurityMetadata` discriminated union for all scheme types
1.6. Define `SecurityRequirement` interface for operation-level requirements
1.7. Define `SecurityExtractionResult` interface for complete extraction output
1.8. Export `extractSecuritySchemes()` function signature
1.9. Add exports to `packages/parser/src/index.ts`

### Task 2: Implement API Key Metadata Types [AC3]
Create API Key specific metadata types and interfaces.

**Subtasks:**
2.1. Define `ApiKeyMetadata` interface with `name` and `in` fields
2.2. Type `in` field as 'header' | 'query' | 'cookie'
2.3. Add JSDoc comments with API Key examples
2.4. Create type guard `isApiKeyScheme()` for runtime checking

### Task 3: Implement HTTP Bearer Metadata Types [AC4]
Create HTTP Bearer specific metadata types and interfaces.

**Subtasks:**
3.1. Define `HttpBearerMetadata` interface with `scheme: 'bearer'`
3.2. Add optional `bearerFormat` field for JWT identification
3.3. Add JSDoc comments with Bearer token examples
3.4. Create type guard `isHttpBearerScheme()` for runtime checking

### Task 4: Implement HTTP Basic Metadata Types [AC5]
Create HTTP Basic specific metadata types and interfaces.

**Subtasks:**
4.1. Define `HttpBasicMetadata` interface with `scheme: 'basic'`
4.2. Add JSDoc comments with Basic auth examples
4.3. Create type guard `isHttpBasicScheme()` for runtime checking

### Task 5: Implement OAuth2 Metadata Types [AC6]
Create OAuth2 specific metadata types and interfaces.

**Subtasks:**
5.1. Define `OAuth2Flows` interface with all flow types
5.2. Define `OAuth2Flow` interface with authorization/token/refresh URLs
5.3. Define scopes as `Record<string, string>` (scope name → description)
5.4. Define `OAuth2Metadata` interface with flows and scopes
5.5. Add JSDoc comments with OAuth2 flow examples
5.6. Create type guard `isOAuth2Scheme()` for runtime checking

### Task 6: Implement OpenID Connect Metadata Types [AC7]
Create OpenID Connect specific metadata types and interfaces.

**Subtasks:**
6.1. Define `OpenIdConnectMetadata` interface with `openIdConnectUrl`
6.2. Add JSDoc comments with OIDC provider examples
6.3. Create type guard `isOpenIdConnectScheme()` for runtime checking

### Task 7: Implement Security Scheme Classification Logic [AC2]
Create the core classification function for all security scheme types.

**Subtasks:**
7.1. Implement `classifySecurityScheme()` function
7.2. Handle `type: 'apiKey'` classification based on `in` field
7.3. Handle `type: 'http'` classification based on `scheme` field
7.4. Handle `type: 'oauth2'` classification with unsupported warning
7.5. Handle `type: 'openIdConnect'` classification with unsupported warning
7.6. Extract metadata for each scheme type
7.7. Set `supported` flag (true for API Key, Bearer, Basic; false for OAuth2, OIDC)
7.8. Generate warnings for unsupported schemes
7.9. Throw error for unknown scheme types

### Task 8: Implement Metadata Extraction Functions [AC3-AC7]
Create metadata extraction functions for each security scheme type.

**Subtasks:**
8.1. Implement `extractApiKeyMetadata()` for API Key schemes
8.2. Implement `extractHttpBearerMetadata()` for Bearer schemes
8.3. Implement `extractHttpBasicMetadata()` for Basic schemes
8.4. Implement `extractOAuth2Metadata()` for OAuth2 schemes
8.5. Implement `extractOpenIdConnectMetadata()` for OIDC schemes
8.6. Validate metadata completeness for code generation

### Task 9: Implement Global Security Extraction [AC8]
Extract global security requirements from document root.

**Subtasks:**
9.1. Implement `extractGlobalSecurity()` function
9.2. Read `document.security` array
9.3. Convert each security object to `SecurityRequirement`
9.4. Extract scheme names from security object keys
9.5. Extract scopes from security object values
9.6. Determine AND/OR logic from object structure
9.7. Validate all scheme references exist in `components.securitySchemes`

### Task 10: Implement Operation-Level Security Extraction [AC8, AC10]
Extract security requirements from individual operations.

**Subtasks:**
10.1. Implement `extractOperationSecurity()` function
10.2. Read `operation.security` array if present
10.3. Handle undefined security (inherit global)
10.4. Handle empty array `[]` (no auth required)
10.5. Handle explicit security requirements (override global)
10.6. Map security requirements to operation IDs
10.7. Validate all scheme references exist

### Task 11: Implement Security Requirement Logic Detection [AC9]
Detect AND/OR logic in multi-scheme security requirements.

**Subtasks:**
11.1. Implement `detectSecurityLogic()` function
11.2. Detect AND logic: multiple schemes in one security object `{ apiKey: [], bearerAuth: [] }`
11.3. Detect OR logic: multiple security objects in array `[{ apiKey: [] }, { bearerAuth: [] }]`
11.4. Store logic type in `SecurityRequirement`
11.5. Add examples to JSDoc comments

### Task 12: Implement Main Security Extraction Function [AC1, AC13]
Create the main entry point for security extraction.

**Subtasks:**
12.1. Implement `extractSecuritySchemes()` function
12.2. Accept `document: OpenAPIDocument` and `operations: OperationMetadata[]` parameters
12.3. Extract schemes from `document.components.securitySchemes`
12.4. Classify each security scheme
12.5. Extract global security requirements
12.6. Extract operation-level security requirements
12.7. Merge global and operation-level security per operation
12.8. Validate all security references
12.9. Collect warnings from all steps
12.10. Return `SecurityExtractionResult`

### Task 13: Implement Security Reference Validation [AC14]
Validate that all security references point to existing schemes.

**Subtasks:**
13.1. Implement `validateSecurityReferences()` function
13.2. Check all global security requirements reference existing schemes
13.3. Check all operation-level security requirements reference existing schemes
13.4. Generate validation errors for orphaned references
13.5. Validate scheme names are valid identifiers

### Task 14: Implement Unsupported Scheme Warning Generation [AC11]
Generate helpful warnings for unsupported or complex schemes.

**Subtasks:**
14.1. Implement `generateSchemeWarnings()` function
14.2. Warn for OAuth2 schemes with manual implementation guidance
14.3. Warn for OpenID Connect schemes with provider setup guidance
14.4. Suggest migration paths for complex schemes
14.5. Include helpful error messages with documentation links

### Task 15: Integrate with CLI Pipeline [AC13]
Integrate security extraction into CLI generate command.

**Subtasks:**
15.1. Import `extractSecuritySchemes` in `packages/cli/src/commands/generate.ts`
15.2. Call after `extractOperations()` completes
15.3. Pass resolved document and operations array
15.4. Log extraction results (scheme count, classifications)
15.5. Log warnings in verbose mode
15.6. Handle extraction errors with ParseError

### Task 16: Add Unit Tests for API Key Schemes [AC15]
Test API Key security scheme extraction.

**Subtasks:**
16.1. Test API Key in header location
16.2. Test API Key in query location
16.3. Test API Key in cookie location
16.4. Test classification as `api-key-header`, `api-key-query`, `api-key-cookie`
16.5. Test metadata extraction (name, in fields)
16.6. Test supported flag is true

### Task 17: Add Unit Tests for HTTP Schemes [AC15]
Test HTTP security scheme extraction.

**Subtasks:**
17.1. Test HTTP Bearer scheme identification
17.2. Test Bearer format extraction (JWT)
17.3. Test HTTP Basic scheme identification
17.4. Test classification as `http-bearer`, `http-basic`
17.5. Test metadata extraction (scheme, bearerFormat)
17.6. Test supported flag is true

### Task 18: Add Unit Tests for OAuth2 Schemes [AC15]
Test OAuth2 security scheme extraction.

**Subtasks:**
18.1. Test OAuth2 implicit flow extraction
18.2. Test OAuth2 authorizationCode flow extraction
18.3. Test OAuth2 clientCredentials flow extraction
18.4. Test OAuth2 password flow extraction
18.5. Test scope extraction from flows
18.6. Test authorization URL and token URL extraction
18.7. Test unsupported warning generation
18.8. Test supported flag is false

### Task 19: Add Unit Tests for OpenID Connect Schemes [AC15]
Test OpenID Connect security scheme extraction.

**Subtasks:**
19.1. Test OpenID Connect URL extraction
19.2. Test classification as `openid-connect`
19.3. Test unsupported warning generation
19.4. Test supported flag is false

### Task 20: Add Unit Tests for Security Requirements [AC15]
Test security requirement extraction and merging.

**Subtasks:**
20.1. Test global security requirement extraction
20.2. Test operation-level security requirement extraction
20.3. Test operation-level override (replaces global)
20.4. Test empty security array (no auth required)
20.5. Test undefined security (inherit global)
20.6. Test AND logic detection (multiple schemes in one object)
20.7. Test OR logic detection (multiple objects in array)
20.8. Test scope extraction for OAuth2 requirements

### Task 21: Add Integration Tests [AC15]
Test complete security extraction with real-world OpenAPI documents.

**Subtasks:**
21.1. Create test fixture: Ozon API document excerpt with security schemes
21.2. Test extraction from complete Ozon API document
21.3. Test pipeline integration: Load → Validate → Resolve → Extract Schemas → Extract Operations → Extract Security
21.4. Verify security requirements linked to operations
21.5. Verify all scheme references validated
21.6. Measure extraction performance (<1 second)

### Task 22: Add Documentation [AC16]
Document security extraction functionality.

**Subtasks:**
22.1. Add `extractSecuritySchemes()` documentation to parser README
22.2. Add JSDoc comments to all exported types and functions
22.3. Create `docs/security-extraction.md` guide
22.4. Document supported vs. unsupported scheme types
22.5. Include multi-scheme requirement examples
22.6. Document OAuth2 manual implementation guidance
22.7. Add security extraction section to main documentation

### Task 23: Add Code Quality Checks [AC17]
Ensure code quality standards are met.

**Subtasks:**
23.1. Run TypeScript compiler in strict mode
23.2. Fix all TypeScript errors and warnings
23.3. Run ESLint and fix all violations
23.4. Run Prettier and format all code
23.5. Verify test coverage ≥80% for security-extractor module
23.6. Run performance benchmark (extraction <1 second)
23.7. Verify no regression in Stories 2.1-2.5 functionality

---

## Dev Notes

### Project Context
**Technology Stack:**
- TypeScript 5.3.3 with strict mode enabled
- Node.js 20.11.0 LTS (ES Modules)
- Vitest 1.2.0 for testing
- pnpm workspace monorepo structure

**Package Structure:**
```
packages/
├── parser/
│   ├── src/
│   │   ├── index.ts                    # Main exports
│   │   ├── loader.ts                   # Story 2.1
│   │   ├── validator.ts                # Story 2.2
│   │   ├── reference-resolver.ts       # Story 2.3
│   │   ├── schema-extractor.ts         # Story 2.4
│   │   ├── operation-extractor.ts      # Story 2.5
│   │   ├── security-extractor.ts       # Story 2.6 (NEW)
│   │   └── types.ts                    # Shared types
│   ├── package.json
│   └── tsconfig.json
├── cli/
│   ├── src/
│   │   └── commands/generate.ts        # CLI integration
│   └── package.json
```

**Dependencies:**
```json
{
  "dependencies": {
    "@apidevtools/swagger-parser": "^10.1.0",
    "js-yaml": "^4.1.0"
  },
  "devDependencies": {
    "@types/node": "^20.11.0",
    "typescript": "^5.3.3",
    "vitest": "^1.2.0"
  }
}
```

### Complete Type Definitions

```typescript
// packages/parser/src/security-extractor.ts

import type { OpenAPI } from '@apidevtools/swagger-parser';
import type { OperationMetadata } from './operation-extractor.js';

/**
 * Map of security scheme names to classified security schemes
 */
export interface SecuritySchemeMap {
  [schemeName: string]: ClassifiedSecurityScheme;
}

/**
 * Classified security scheme with authentication type and metadata
 */
export interface ClassifiedSecurityScheme {
  name: string;
  type: 'apiKey' | 'http' | 'oauth2' | 'openIdConnect';
  classification: SecurityClassification;
  metadata: SecurityMetadata;
  supported: boolean;
  warnings?: string[];
}

/**
 * Security scheme classification by authentication type
 */
export type SecurityClassification =
  | 'api-key-header'    // API Key in header
  | 'api-key-query'     // API Key in query parameter
  | 'api-key-cookie'    // API Key in cookie
  | 'http-bearer'       // HTTP Bearer token
  | 'http-basic'        // HTTP Basic authentication
  | 'oauth2'            // OAuth2 (requires manual implementation)
  | 'openid-connect';   // OpenID Connect (requires manual implementation)

/**
 * Discriminated union of security metadata types
 */
export type SecurityMetadata =
  | ApiKeyMetadata
  | HttpBearerMetadata
  | HttpBasicMetadata
  | OAuth2Metadata
  | OpenIdConnectMetadata;

/**
 * API Key authentication metadata
 * @example
 * {
 *   name: 'X-API-Key',
 *   in: 'header'
 * }
 */
export interface ApiKeyMetadata {
  name: string;
  in: 'header' | 'query' | 'cookie';
}

/**
 * HTTP Bearer token metadata
 * @example
 * {
 *   scheme: 'bearer',
 *   bearerFormat: 'JWT'
 * }
 */
export interface HttpBearerMetadata {
  scheme: 'bearer';
  bearerFormat?: string;
}

/**
 * HTTP Basic authentication metadata
 */
export interface HttpBasicMetadata {
  scheme: 'basic';
}

/**
 * OAuth2 authentication metadata
 */
export interface OAuth2Metadata {
  flows: OAuth2Flows;
}

/**
 * OAuth2 flows configuration
 */
export interface OAuth2Flows {
  implicit?: OAuth2Flow;
  authorizationCode?: OAuth2Flow;
  clientCredentials?: OAuth2Flow;
  password?: OAuth2Flow;
}

/**
 * OAuth2 flow details
 */
export interface OAuth2Flow {
  authorizationUrl?: string;
  tokenUrl?: string;
  refreshUrl?: string;
  scopes: Record<string, string>;
}

/**
 * OpenID Connect authentication metadata
 */
export interface OpenIdConnectMetadata {
  openIdConnectUrl: string;
}

/**
 * Security requirement for operations
 */
export interface SecurityRequirement {
  schemes: string[];
  scopes: Record<string, string[]>;
  logic: 'AND' | 'OR';
}

/**
 * Complete security extraction result
 */
export interface SecurityExtractionResult {
  schemes: SecuritySchemeMap;
  globalRequirements: SecurityRequirement[];
  operationRequirements: Map<string, SecurityRequirement[]>;
  warnings: string[];
}

/**
 * Extract and classify security schemes from OpenAPI document
 */
export function extractSecuritySchemes(
  document: OpenAPI.Document,
  operations: OperationMetadata[]
): SecurityExtractionResult;

/**
 * Classify a single security scheme
 */
export function classifySecurityScheme(
  name: string,
  scheme: any
): ClassifiedSecurityScheme;

/**
 * Extract security requirements from security array
 */
export function extractSecurityRequirements(
  securityArray: any[]
): SecurityRequirement[];

/**
 * Type guards for runtime checking
 */
export function isApiKeyScheme(scheme: any): scheme is { type: 'apiKey'; name: string; in: 'header' | 'query' | 'cookie' };
export function isHttpBearerScheme(scheme: any): scheme is { type: 'http'; scheme: 'bearer'; bearerFormat?: string };
export function isHttpBasicScheme(scheme: any): scheme is { type: 'http'; scheme: 'basic' };
export function isOAuth2Scheme(scheme: any): scheme is { type: 'oauth2'; flows: any };
export function isOpenIdConnectScheme(scheme: any): scheme is { type: 'openIdConnect'; openIdConnectUrl: string };
```

### Complete Implementation

```typescript
// packages/parser/src/security-extractor.ts

import type { OpenAPI } from '@apidevtools/swagger-parser';
import type { OperationMetadata } from './operation-extractor.js';

// [Type definitions from above]

/**
 * Extract and classify security schemes from OpenAPI document
 */
export function extractSecuritySchemes(
  document: OpenAPI.Document,
  operations: OperationMetadata[]
): SecurityExtractionResult {
  const schemes: SecuritySchemeMap = {};
  const warnings: string[] = [];

  // Extract and classify security schemes from components
  if (document.components?.securitySchemes) {
    for (const [name, rawScheme] of Object.entries(document.components.securitySchemes)) {
      const classifiedScheme = classifySecurityScheme(name, rawScheme);
      schemes[name] = classifiedScheme;

      if (classifiedScheme.warnings) {
        warnings.push(...classifiedScheme.warnings);
      }
    }
  }

  // Extract global security requirements
  const globalRequirements = document.security
    ? extractSecurityRequirements(document.security)
    : [];

  // Extract operation-level security requirements
  const operationRequirements = new Map<string, SecurityRequirement[]>();

  for (const operation of operations) {
    const opSecurity = getOperationSecurity(operation, globalRequirements);
    if (opSecurity.length > 0) {
      operationRequirements.set(operation.operationId, opSecurity);
    }
  }

  // Validate all security references
  validateSecurityReferences(schemes, globalRequirements, operationRequirements, warnings);

  return {
    schemes,
    globalRequirements,
    operationRequirements,
    warnings
  };
}

/**
 * Classify a single security scheme by type
 */
export function classifySecurityScheme(
  name: string,
  scheme: any
): ClassifiedSecurityScheme {
  let classification: SecurityClassification;
  let supported = true;
  const warnings: string[] = [];
  let metadata: SecurityMetadata;

  switch (scheme.type) {
    case 'apiKey':
      classification = `api-key-${scheme.in}` as SecurityClassification;
      metadata = extractApiKeyMetadata(scheme);
      break;

    case 'http':
      if (scheme.scheme === 'bearer') {
        classification = 'http-bearer';
        metadata = extractHttpBearerMetadata(scheme);
      } else if (scheme.scheme === 'basic') {
        classification = 'http-basic';
        metadata = extractHttpBasicMetadata(scheme);
      } else {
        classification = 'http-bearer';
        metadata = { scheme: 'bearer' };
        warnings.push(`Unsupported HTTP scheme '${scheme.scheme}' for '${name}'. Treating as bearer.`);
      }
      break;

    case 'oauth2':
      classification = 'oauth2';
      metadata = extractOAuth2Metadata(scheme);
      supported = false;
      warnings.push(
        `OAuth2 scheme '${name}' requires manual implementation. ` +
        `Generated code provides placeholder. See Epic 4 authentication documentation.`
      );
      break;

    case 'openIdConnect':
      classification = 'openid-connect';
      metadata = extractOpenIdConnectMetadata(scheme);
      supported = false;
      warnings.push(
        `OpenID Connect scheme '${name}' requires manual implementation. ` +
        `Configure OIDC provider at: ${scheme.openIdConnectUrl}`
      );
      break;

    default:
      throw new Error(
        `Unknown security scheme type '${scheme.type}' for '${name}'. ` +
        `Supported types: apiKey, http, oauth2, openIdConnect.`
      );
  }

  return {
    name,
    type: scheme.type,
    classification,
    metadata,
    supported,
    warnings: warnings.length > 0 ? warnings : undefined
  };
}

/**
 * Extract API Key metadata
 */
function extractApiKeyMetadata(scheme: any): ApiKeyMetadata {
  return {
    name: scheme.name,
    in: scheme.in
  };
}

/**
 * Extract HTTP Bearer metadata
 */
function extractHttpBearerMetadata(scheme: any): HttpBearerMetadata {
  return {
    scheme: 'bearer',
    bearerFormat: scheme.bearerFormat
  };
}

/**
 * Extract HTTP Basic metadata
 */
function extractHttpBasicMetadata(scheme: any): HttpBasicMetadata {
  return {
    scheme: 'basic'
  };
}

/**
 * Extract OAuth2 metadata
 */
function extractOAuth2Metadata(scheme: any): OAuth2Metadata {
  return {
    flows: scheme.flows
  };
}

/**
 * Extract OpenID Connect metadata
 */
function extractOpenIdConnectMetadata(scheme: any): OpenIdConnectMetadata {
  return {
    openIdConnectUrl: scheme.openIdConnectUrl
  };
}

/**
 * Extract security requirements from OpenAPI security array
 *
 * @example
 * // AND logic: both schemes required
 * [{ apiKey: [], bearerAuth: [] }]
 *
 * @example
 * // OR logic: either scheme acceptable
 * [{ apiKey: [] }, { bearerAuth: [] }]
 */
export function extractSecurityRequirements(
  securityArray: any[]
): SecurityRequirement[] {
  return securityArray.map(securityObj => {
    const schemes = Object.keys(securityObj);
    const scopes: Record<string, string[]> = {};

    schemes.forEach(scheme => {
      scopes[scheme] = securityObj[scheme] || [];
    });

    // Multiple schemes in one object = AND logic (all required)
    // Multiple objects in array = OR logic (any acceptable)
    const logic = schemes.length > 1 ? 'AND' : 'OR';

    return { schemes, scopes, logic };
  });
}

/**
 * Get effective security requirements for an operation
 * - If operation.security is defined: use it (even if empty)
 * - If operation.security is undefined: inherit global
 */
function getOperationSecurity(
  operation: any,
  globalRequirements: SecurityRequirement[]
): SecurityRequirement[] {
  // Check if operation has explicit security
  if ('security' in operation) {
    // Empty array [] means no authentication required
    if (operation.security.length === 0) {
      return [];
    }
    // Non-empty array means operation-level override
    return extractSecurityRequirements(operation.security);
  }

  // No explicit security means inherit global
  return globalRequirements;
}

/**
 * Validate that all security requirements reference existing schemes
 */
function validateSecurityReferences(
  schemes: SecuritySchemeMap,
  globalRequirements: SecurityRequirement[],
  operationRequirements: Map<string, SecurityRequirement[]>,
  warnings: string[]
): void {
  const schemeNames = new Set(Object.keys(schemes));

  // Validate global requirements
  for (const requirement of globalRequirements) {
    for (const schemeName of requirement.schemes) {
      if (!schemeNames.has(schemeName)) {
        warnings.push(
          `Global security requirement references unknown scheme '${schemeName}'. ` +
          `Available schemes: ${Array.from(schemeNames).join(', ')}`
        );
      }
    }
  }

  // Validate operation requirements
  for (const [operationId, requirements] of operationRequirements.entries()) {
    for (const requirement of requirements) {
      for (const schemeName of requirement.schemes) {
        if (!schemeNames.has(schemeName)) {
          warnings.push(
            `Operation '${operationId}' references unknown scheme '${schemeName}'. ` +
            `Available schemes: ${Array.from(schemeNames).join(', ')}`
          );
        }
      }
    }
  }
}

/**
 * Type guards for runtime checking
 */
export function isApiKeyScheme(scheme: any): scheme is { type: 'apiKey'; name: string; in: 'header' | 'query' | 'cookie' } {
  return scheme?.type === 'apiKey' && typeof scheme.name === 'string' && ['header', 'query', 'cookie'].includes(scheme.in);
}

export function isHttpBearerScheme(scheme: any): scheme is { type: 'http'; scheme: 'bearer'; bearerFormat?: string } {
  return scheme?.type === 'http' && scheme.scheme === 'bearer';
}

export function isHttpBasicScheme(scheme: any): scheme is { type: 'http'; scheme: 'basic' } {
  return scheme?.type === 'http' && scheme.scheme === 'basic';
}

export function isOAuth2Scheme(scheme: any): scheme is { type: 'oauth2'; flows: any } {
  return scheme?.type === 'oauth2' && scheme.flows !== undefined;
}

export function isOpenIdConnectScheme(scheme: any): scheme is { type: 'openIdConnect'; openIdConnectUrl: string } {
  return scheme?.type === 'openIdConnect' && typeof scheme.openIdConnectUrl === 'string';
}
```

### CLI Integration

```typescript
// packages/cli/src/commands/generate.ts

import { loadOpenAPIDocument } from '@openapi-to-mcp/parser';
import { validateOpenAPISchema } from '@openapi-to-mcp/parser';
import { resolveReferences } from '@openapi-to-mcp/parser';
import { extractSchemas } from '@openapi-to-mcp/parser';
import { extractOperations } from '@openapi-to-mcp/parser';
import { extractSecuritySchemes } from '@openapi-to-mcp/parser';
import { logger } from '../utils/logger.js';
import { ParseError } from '../errors.js';
import path from 'node:path';

export async function generateCommand(openApiPath: string, options: GenerateOptions) {
  logger.info('Starting OpenAPI to MCP generation...');

  // Story 2.1: Load OpenAPI document
  logger.info(`Loading OpenAPI document: ${openApiPath}`);
  const document = await loadOpenAPIDocument(openApiPath);
  logger.success('Document loaded successfully');

  // Story 2.2: Validate schema
  logger.info('Validating OpenAPI schema...');
  const validationResult = await validateOpenAPISchema(document);

  if (!validationResult.valid) {
    logger.error('OpenAPI schema validation failed:');
    validationResult.errors.forEach(err => {
      logger.error(`  - ${err.message} (${err.path})`);
    });
    throw new ParseError('OpenAPI schema validation failed', validationResult.errors);
  }

  if (validationResult.warnings.length > 0 && options.verbose) {
    validationResult.warnings.forEach(warn => {
      logger.warn(`  - ${warn.message}`);
    });
  }
  logger.success('Schema validation passed');

  // Story 2.3: Resolve references
  logger.info('Resolving OpenAPI references...');
  const resolutionResult = await resolveReferences(document, path.dirname(openApiPath));

  if (resolutionResult.errors.length > 0) {
    logger.error('Reference resolution failed:');
    resolutionResult.errors.forEach(err => {
      logger.error(`  - ${err.message}`);
    });
    throw new ParseError('Reference resolution failed', resolutionResult.errors);
  }
  logger.success(`Resolved ${resolutionResult.resolved} references`);

  // Story 2.4: Extract schemas
  logger.info('Extracting schemas...');
  const schemaMap = extractSchemas(resolutionResult.document);
  logger.success(`Extracted ${schemaMap.size} schemas`);

  // Story 2.5: Extract operations
  logger.info('Extracting operations...');
  const operations = extractOperations(resolutionResult.document, schemaMap);
  logger.success(`Extracted ${operations.length} operations`);

  // Story 2.6: Extract security schemes
  logger.info('Extracting security schemes...');
  const securityResult = extractSecuritySchemes(resolutionResult.document, operations);

  const schemeCount = Object.keys(securityResult.schemes).length;
  logger.success(`Extracted ${schemeCount} security schemes`);

  if (securityResult.warnings.length > 0) {
    securityResult.warnings.forEach(warning => {
      logger.warn(`Security: ${warning}`);
    });
  }

  if (options.verbose) {
    Object.entries(securityResult.schemes).forEach(([name, scheme]) => {
      const supportStatus = scheme.supported ? 'supported' : 'manual implementation required';
      logger.debug(`  - ${name}: ${scheme.classification} (${supportStatus})`);
    });
  }

  // Continue with tag extraction (Story 2.7)...
  logger.info('Continuing with tag extraction...');
}
```

### Testing

```typescript
// packages/parser/src/security-extractor.test.ts

import { describe, it, expect } from 'vitest';
import { extractSecuritySchemes, classifySecurityScheme } from './security-extractor.js';
import type { OpenAPI } from '@apidevtools/swagger-parser';

describe('Security Extractor', () => {
  describe('API Key Schemes', () => {
    it('should extract API Key in header', () => {
      const scheme = {
        type: 'apiKey',
        name: 'X-API-Key',
        in: 'header'
      };

      const result = classifySecurityScheme('apiKey', scheme);

      expect(result.classification).toBe('api-key-header');
      expect(result.metadata).toEqual({
        name: 'X-API-Key',
        in: 'header'
      });
      expect(result.supported).toBe(true);
    });

    it('should extract API Key in query', () => {
      const scheme = {
        type: 'apiKey',
        name: 'api_key',
        in: 'query'
      };

      const result = classifySecurityScheme('apiKey', scheme);

      expect(result.classification).toBe('api-key-query');
      expect(result.metadata).toEqual({
        name: 'api_key',
        in: 'query'
      });
    });

    it('should extract API Key in cookie', () => {
      const scheme = {
        type: 'apiKey',
        name: 'session',
        in: 'cookie'
      };

      const result = classifySecurityScheme('apiKey', scheme);

      expect(result.classification).toBe('api-key-cookie');
      expect(result.metadata).toEqual({
        name: 'session',
        in: 'cookie'
      });
    });
  });

  describe('HTTP Bearer Schemes', () => {
    it('should identify HTTP Bearer scheme', () => {
      const scheme = {
        type: 'http',
        scheme: 'bearer'
      };

      const result = classifySecurityScheme('bearerAuth', scheme);

      expect(result.classification).toBe('http-bearer');
      expect(result.metadata).toEqual({
        scheme: 'bearer'
      });
      expect(result.supported).toBe(true);
    });

    it('should extract bearer format (JWT)', () => {
      const scheme = {
        type: 'http',
        scheme: 'bearer',
        bearerFormat: 'JWT'
      };

      const result = classifySecurityScheme('bearerAuth', scheme);

      expect(result.metadata).toEqual({
        scheme: 'bearer',
        bearerFormat: 'JWT'
      });
    });
  });

  describe('HTTP Basic Schemes', () => {
    it('should identify HTTP Basic scheme', () => {
      const scheme = {
        type: 'http',
        scheme: 'basic'
      };

      const result = classifySecurityScheme('basicAuth', scheme);

      expect(result.classification).toBe('http-basic');
      expect(result.metadata).toEqual({
        scheme: 'basic'
      });
      expect(result.supported).toBe(true);
    });
  });

  describe('OAuth2 Schemes', () => {
    it('should extract OAuth2 scheme with flows', () => {
      const scheme = {
        type: 'oauth2',
        flows: {
          authorizationCode: {
            authorizationUrl: 'https://example.com/oauth/authorize',
            tokenUrl: 'https://example.com/oauth/token',
            scopes: {
              'read:users': 'Read user data',
              'write:users': 'Write user data'
            }
          }
        }
      };

      const result = classifySecurityScheme('oauth2', scheme);

      expect(result.classification).toBe('oauth2');
      expect(result.supported).toBe(false);
      expect(result.warnings).toContain(
        expect.stringContaining('OAuth2 scheme \'oauth2\' requires manual implementation')
      );
    });
  });

  describe('OpenID Connect Schemes', () => {
    it('should extract OpenID Connect scheme', () => {
      const scheme = {
        type: 'openIdConnect',
        openIdConnectUrl: 'https://example.com/.well-known/openid-configuration'
      };

      const result = classifySecurityScheme('oidc', scheme);

      expect(result.classification).toBe('openid-connect');
      expect(result.metadata).toEqual({
        openIdConnectUrl: 'https://example.com/.well-known/openid-configuration'
      });
      expect(result.supported).toBe(false);
      expect(result.warnings).toContain(
        expect.stringContaining('OpenID Connect scheme \'oidc\' requires manual implementation')
      );
    });
  });

  describe('Security Requirements', () => {
    it('should extract global security requirements', () => {
      const document = {
        openapi: '3.0.0',
        info: { title: 'Test', version: '1.0.0' },
        paths: {},
        components: {
          securitySchemes: {
            apiKey: { type: 'apiKey', name: 'X-API-Key', in: 'header' }
          }
        },
        security: [{ apiKey: [] }]
      } as OpenAPI.Document;

      const result = extractSecuritySchemes(document, []);

      expect(result.globalRequirements).toHaveLength(1);
      expect(result.globalRequirements[0].schemes).toEqual(['apiKey']);
      expect(result.globalRequirements[0].logic).toBe('OR');
    });

    it('should detect AND logic for multi-scheme requirements', () => {
      const document = {
        openapi: '3.0.0',
        info: { title: 'Test', version: '1.0.0' },
        paths: {},
        components: {
          securitySchemes: {
            apiKey: { type: 'apiKey', name: 'X-API-Key', in: 'header' },
            bearerAuth: { type: 'http', scheme: 'bearer' }
          }
        },
        security: [{ apiKey: [], bearerAuth: [] }]
      } as OpenAPI.Document;

      const result = extractSecuritySchemes(document, []);

      expect(result.globalRequirements[0].schemes).toEqual(['apiKey', 'bearerAuth']);
      expect(result.globalRequirements[0].logic).toBe('AND');
    });

    it('should detect OR logic for alternative schemes', () => {
      const document = {
        openapi: '3.0.0',
        info: { title: 'Test', version: '1.0.0' },
        paths: {},
        components: {
          securitySchemes: {
            apiKey: { type: 'apiKey', name: 'X-API-Key', in: 'header' },
            bearerAuth: { type: 'http', scheme: 'bearer' }
          }
        },
        security: [{ apiKey: [] }, { bearerAuth: [] }]
      } as OpenAPI.Document;

      const result = extractSecuritySchemes(document, []);

      expect(result.globalRequirements).toHaveLength(2);
      expect(result.globalRequirements[0].schemes).toEqual(['apiKey']);
      expect(result.globalRequirements[0].logic).toBe('OR');
      expect(result.globalRequirements[1].schemes).toEqual(['bearerAuth']);
      expect(result.globalRequirements[1].logic).toBe('OR');
    });
  });

  describe('Integration', () => {
    it('should extract security from complete OpenAPI document', () => {
      const document = {
        openapi: '3.0.0',
        info: { title: 'Test API', version: '1.0.0' },
        paths: {
          '/users': {
            get: {
              operationId: 'getUsers',
              responses: { '200': { description: 'Success' } }
            }
          }
        },
        components: {
          securitySchemes: {
            apiKey: { type: 'apiKey', name: 'X-API-Key', in: 'header' },
            bearerAuth: { type: 'http', scheme: 'bearer', bearerFormat: 'JWT' }
          }
        },
        security: [{ apiKey: [] }]
      } as OpenAPI.Document;

      const operations = [
        {
          operationId: 'getUsers',
          path: '/users',
          method: 'get',
          parameters: [],
          responses: {}
        }
      ];

      const result = extractSecuritySchemes(document, operations);

      expect(Object.keys(result.schemes)).toHaveLength(2);
      expect(result.schemes.apiKey.classification).toBe('api-key-header');
      expect(result.schemes.bearerAuth.classification).toBe('http-bearer');
      expect(result.globalRequirements).toHaveLength(1);
      expect(result.operationRequirements.get('getUsers')).toHaveLength(1);
      expect(result.warnings).toHaveLength(0);
    });
  });
});
```

### Performance Requirements
- Security extraction must complete in <1 second for typical API documents
- Support for APIs with 10-50 security schemes
- Efficient scheme classification and validation
- Minimal memory overhead for security metadata storage

### Error Handling
- Throw `ParseError` for unknown security scheme types
- Generate warnings for unsupported OAuth2 and OIDC schemes
- Validate all security references and warn about orphaned references
- Handle missing security schemes gracefully

### Dependencies
- **Internal:** Story 2.3 (resolved document), Story 2.5 (operations array)
- **External:** `@apidevtools/swagger-parser` for OpenAPI types
- **Epic 4:** Security metadata consumed by authentication handler generation

---

## Change Log

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-01-04 | 1.0 | System | Initial story creation |
| 2025-01-04 | 2.0 | Claude (PO) | Restructured to match story template format with complete implementation |

---

## Dev Agent Record

### Agent Attempts

No dev agent attempts yet. Story is in Draft status.

### Implementation Notes

Will be filled during development phase.

---

## QA Results

### Test Execution Summary

No QA results yet. Story is in Draft status.

### Issues Found

Will be documented during QA phase.

---

## Notes

- **Epic Sequence:** Story 2.6 builds on Stories 2.1-2.5 and precedes Story 2.7 (Tag Extraction)
- **Dependency:** Stories 2.1-2.5 must be complete before starting this story
- **Next Story:** Story 2.7 will extract and categorize API tags
- **Testing Focus:** All security scheme types, multi-scheme AND/OR logic, global vs. operation-level merging
- **Performance:** Security extraction should be very fast (<1 second)
- **Epic 4 Integration:** Security metadata will be consumed by authentication handler generation
- **Edge Cases:** OAuth2 flows complexity, no security requirements, operation-level overrides, orphaned references
