# Story 3.1: Code Generation Architecture and Template Engine Setup - Brownfield Addition

**Epic:** Epic 3: TypeScript Code Generation System

---

## User Story

**As a** developer,
**I want** a template engine architecture for generating code from parsed OpenAPI data,
**So that** I can produce consistent, maintainable TypeScript code.

---

## Story Context

**Existing System Integration:**

- Integrates with: Parser package from Epic 2, CLI package from Epic 1
- Technology: TypeScript 5.x, template engine (Handlebars/EJS), code formatting (Prettier)
- Follows pattern: Generator package structure, template-based code generation
- Touch points: Parser output from Epic 2, file system utilities from Story 1.4

**Epic Context:**

This story establishes the foundation for Epic 3's code generation system. After the parser produces structured data (Epic 2), we need a generation engine that transforms that data into production-ready TypeScript code. This story creates the generator package architecture, template engine integration, and core rendering pipeline.

**Project Context:**

The code generation architecture is the bridge between parsing (Epic 2) and the generated MCP server output. This story sets up the infrastructure that all subsequent generation stories (3.2-3.9) will build upon. The template engine must support both simple boilerplate generation and complex TypeScript code generation with proper formatting.

---

## Acceptance Criteria

### Functional Requirements

1. **Generator Package Creation**
   - Create `packages/generator/` directory with proper structure
   - Initialize `package.json` with dependencies
   - Create `src/` directory with main entry point
   - Configure TypeScript for generator package
   - Set up exports for generator functions

2. **Template Engine Selection and Integration**
   - Evaluate template engines: Handlebars, EJS, or similar
   - Select based on: ease of use, TypeScript support, performance
   - Install and configure chosen template engine
   - Create template helper registration system
   - Document template engine choice and rationale

3. **Template Directory Structure**
   - Create `packages/templates/mcp-server/` directory
   - Subdirectories: `src/`, `config/`, `docs/`
   - Template file naming convention: `*.ts.hbs` or `*.ts.ejs`
   - Organize by component type (client, server, types, etc.)
   - Document template structure in README

4. **Generator Architecture Pipeline**
   - Implement pipeline: `parseData → templateData → renderTemplate → writeOutput`
   - Create `GeneratorContext` with all necessary data
   - Support for multiple template rendering in sequence
   - Coordinate file writing with proper directory structure
   - Handle template dependencies and ordering

5. **Core Rendering Function**
   - Create `generateFromTemplate(templatePath, data, outputPath)` function
   - Load template file from disk
   - Compile template with template engine
   - Render with provided data
   - Return rendered string for writing or validation
   - Handle template errors with clear messages

6. **Template Helper Functions**
   - Case conversion: `camelCase`, `PascalCase`, `kebab-case`, `snake_case`
   - Type conversion: OpenAPI type → TypeScript type mapping
   - String utilities: `capitalize`, `pluralize`, `escape`
   - Code formatting: `indent`, `formatComment`
   - Conditional helpers: `if`, `unless`, `each`, `with`
   - Register all helpers with template engine

7. **Template Data Model**
   - Define `TemplateDataModel` interface
   - Include: `apiName`, `operations`, `schemas`, `securitySchemes`, `servers`, `metadata`
   - Transform parser output to template-friendly format
   - Add computed properties for template convenience
   - Validate data model before rendering

8. **Code Formatting Integration**
   - Install and configure Prettier
   - Create Prettier config: `.prettierrc` for generated code
   - Format all generated TypeScript code automatically
   - Settings: 2-space indent, single quotes, trailing commas, 100 char line length
   - Validate formatted output compiles correctly

9. **Template Validation**
   - Validate all required data fields present before rendering
   - Check template file exists before loading
   - Verify output path is valid and writable
   - Validate rendered output is valid TypeScript (syntax check)
   - Report missing variables or template errors clearly

10. **Error Handling**
    - Custom `GenerationError` class for generation failures
    - Template rendering errors include: template name, line number, missing variable
    - File writing errors include: output path, permission issues
    - Collect multiple errors before reporting
    - Provide actionable error messages with fix suggestions

11. **Test Suite Setup**
    - Create `packages/generator/__tests__/` directory
    - Unit test: Template rendering with sample data
    - Unit test: Helper function correctness (case conversion, type mapping)
    - Unit test: Template validation (missing data)
    - Unit test: Error handling for invalid templates
    - Integration test: Full generation pipeline
    - Test coverage ≥80% for generator module

### Integration Requirements

12. **Parser Integration**
    - Receive parser output from Epic 2 (`ParseResult`)
    - Transform `ParseResult` to `TemplateDataModel`
    - Validate parser output completeness
    - Handle parser warnings in generation

13. **CLI Integration**
    - Generator invoked from CLI `generate` command
    - Receive output directory from CLI options
    - Report generation progress to CLI logger
    - Return generation result to CLI for summary

14. **File System Integration**
    - Use file system utilities from Story 1.4
    - Create output directory structure
    - Write generated files to disk
    - Handle existing files (overwrite with `--force` flag)
    - Preserve file permissions and timestamps

### Quality Requirements

15. **Documentation**
    - Document generator architecture in `docs/generation-architecture.md`
    - Create template development guide
    - Document helper functions with examples
    - Include template data model reference
    - Add troubleshooting section for common issues

16. **Code Quality**
    - TypeScript strict mode compliance
    - ESLint and Prettier checks pass
    - No regression in Epic 1-2 functionality
    - Template rendering <100ms per template

17. **Performance**
    - Template compilation cached for repeated renders
    - Parallel template rendering where possible
    - Memory-efficient for large APIs (300+ operations)
    - Generation completes in <30 seconds for 50-method API

---

## Technical Notes

### Integration Approach

**Generator Package Structure:**
```
packages/generator/
├── src/
│   ├── index.ts              # Main entry point
│   ├── generator.ts          # Core generator logic
│   ├── template-engine.ts    # Template engine wrapper
│   ├── helpers.ts            # Template helper functions
│   ├── data-transformer.ts   # Parser → Template data
│   └── formatters.ts         # Code formatting utilities
├── __tests__/
│   ├── generator.test.ts
│   ├── helpers.test.ts
│   └── fixtures/
└── package.json
```

**Template Data Model:**
```typescript
// packages/generator/src/types.ts
export interface TemplateDataModel {
  apiName: string;
  apiVersion: string;
  apiDescription?: string;

  // From parser
  schemas: SchemaTemplateData[];
  operations: OperationTemplateData[];
  securitySchemes: SecuritySchemeTemplateData[];
  tags: TagTemplateData[];
  servers: ServerTemplateData[];

  // Computed properties
  hasAuthentication: boolean;
  primaryServer: ServerTemplateData;
  packageName: string;

  // Metadata
  generatedAt: string;
  generatorVersion: string;
}

export interface SchemaTemplateData {
  name: string;
  pascalName: string;
  camelName: string;
  properties: PropertyTemplateData[];
  required: string[];
  hasRequired: boolean;
  // ... other schema metadata
}
```

**Core Generator Function:**
```typescript
// packages/generator/src/generator.ts
import Handlebars from 'handlebars';
import { registerHelpers } from './helpers';

export class CodeGenerator {
  private templateEngine: typeof Handlebars;

  constructor() {
    this.templateEngine = Handlebars.create();
    registerHelpers(this.templateEngine);
  }

  async generateFromTemplate(
    templatePath: string,
    data: any,
    outputPath?: string
  ): Promise<string> {
    // Load template
    const templateContent = await fs.readFile(templatePath, 'utf-8');

    // Compile template
    const template = this.templateEngine.compile(templateContent);

    // Render with data
    const rendered = template(data);

    // Format with Prettier
    const formatted = await this.formatCode(rendered);

    // Write to output if path provided
    if (outputPath) {
      await fs.writeFile(outputPath, formatted, 'utf-8');
    }

    return formatted;
  }

  private async formatCode(code: string): Promise<string> {
    const prettier = await import('prettier');
    return prettier.format(code, {
      parser: 'typescript',
      singleQuote: true,
      trailingComma: 'all',
      printWidth: 100,
      tabWidth: 2
    });
  }
}
```

**Template Helpers:**
```typescript
// packages/generator/src/helpers.ts
export function registerHelpers(engine: typeof Handlebars) {
  // Case conversion
  engine.registerHelper('camelCase', (str: string) => {
    return str.replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '');
  });

  engine.registerHelper('PascalCase', (str: string) => {
    const camel = camelCase(str);
    return camel.charAt(0).toUpperCase() + camel.slice(1);
  });

  // Type conversion
  engine.registerHelper('toTsType', (openApiType: string) => {
    const typeMap: Record<string, string> = {
      'string': 'string',
      'number': 'number',
      'integer': 'number',
      'boolean': 'boolean',
      'array': 'Array',
      'object': 'object'
    };
    return typeMap[openApiType] || 'any';
  });

  // Conditional helpers
  engine.registerHelper('eq', (a: any, b: any) => a === b);
  engine.registerHelper('gt', (a: number, b: number) => a > b);
}
```

**CLI Integration:**
```typescript
// packages/cli/src/commands/generate.ts
import { parseOpenAPIDocument } from '@openapi-to-mcp/parser';
import { CodeGenerator } from '@openapi-to-mcp/generator';

async function generateCommand(openApiPath: string, options: Options) {
  // Epic 2: Parse OpenAPI document
  const parseResult = await parseOpenAPIDocument(openApiPath);

  logger.info('Generating MCP server code...');

  // Epic 3: Generate code
  const generator = new CodeGenerator();
  const outputDir = options.output || './generated-server';

  await generator.generateProject(parseResult, outputDir);

  logger.info(`✓ Code generated successfully at ${outputDir}`);
}
```

### Existing Pattern Reference

- **Package Structure:** Monorepo workspace from Epic 1 Story 1.1
- **Error Handling:** Use error classes from Story 1.7
- **Testing Framework:** Jest configuration from Story 1.6
- **File System:** File utilities from Story 1.4

### Key Constraints

- **No Breaking Changes:** Must not modify Epic 1-2 interfaces
- **Performance:** Template rendering <100ms per template
- **Code Quality:** All generated code must be valid TypeScript
- **Formatting:** Prettier must format all output
- **Template Engine:** Choose based on community support and TypeScript compatibility

### Dependencies

**External Libraries:**
- `handlebars@^4.7.8` (or `ejs@^3.1.9`) - Template engine
- `prettier@^3.1.0` - Code formatting
- `@types/handlebars@^4.1.0` - TypeScript types

**Internal Dependencies:**
- Epic 2: Parser output (`ParseResult`)
- Story 1.4: File system utilities
- Story 1.7: Error handling classes
- Stories 3.2-3.9: Will consume generator infrastructure

---

## Definition of Done

- [x] Functional requirements 1-11 met
- [x] Integration requirements 12-14 verified
- [x] Generator package created (`packages/generator/`)
- [x] Template engine selected and integrated
- [x] Template directory structure created
- [x] Generator pipeline implemented
- [x] Core rendering function implemented
- [x] Template helper functions created and tested
- [x] Template data model defined
- [x] Code formatting integration working (Prettier)
- [x] Template validation implemented
- [x] Error handling complete with clear messages
- [x] Test suite created with ≥80% coverage
- [x] Parser integration successful
- [x] CLI integration working
- [x] File system integration working
- [x] Documentation complete (architecture, guides, API reference)
- [x] Code quality checks pass (TypeScript, ESLint, Prettier)
- [x] Performance validated (<100ms per template)
- [x] Epic 1-2 functionality regression tested
- [x] All tests pass

---

## Risk and Compatibility Check

### Minimal Risk Assessment

**Primary Risk:** Template engine choice limiting flexibility or causing performance issues

**Mitigation:**
- Evaluate multiple template engines before selection
- Create abstraction layer for template engine (can swap if needed)
- Performance testing with realistic data (300+ operations)
- Comprehensive helper library for template convenience
- Cache compiled templates for performance

**Rollback:**
- Generator package can be removed from workspaces
- No changes to Epic 1-2 packages
- No state or persistent changes

### Compatibility Verification

- [x] No breaking changes to existing APIs (Epic 1-2 unchanged)
- [x] Database changes: N/A (no database)
- [x] Parser output consumed correctly
- [x] Performance acceptable for large APIs
- [x] Generated code valid TypeScript

---

## Validation Checklist

### Scope Validation

- [x] Story can be completed in one development session (6-8 hours)
- [x] Integration approach is straightforward
- [x] Follows existing patterns (monorepo, error handling, testing)
- [x] Foundation for remaining Epic 3 stories

### Clarity Check

- [x] Story requirements are unambiguous
- [x] Integration points clearly specified
- [x] Success criteria are testable
- [x] Template engine selection criteria defined

---

## Success Criteria

The story is successful when:

1. ✅ Generator package created with proper structure
2. ✅ Template engine selected and integrated
3. ✅ Core rendering pipeline implemented
4. ✅ Template helper functions working (case conversion, type mapping)
5. ✅ Code formatting integration successful (Prettier)
6. ✅ Template validation prevents errors
7. ✅ Error handling provides clear, actionable messages
8. ✅ Parser integration successful (transforms `ParseResult`)
9. ✅ CLI integration working (invoked from generate command)
10. ✅ Test coverage ≥80% with all tests passing
11. ✅ Documentation complete
12. ✅ Performance targets met (<100ms per template)
13. ✅ Ready for Stories 3.2-3.9 to build upon

---

## Notes

- **Epic Sequence:** Story 3.1 is the foundation for all Epic 3 stories
- **Dependency:** Epic 2 must be complete before starting this story
- **Next Story:** Story 3.2 (TypeScript Interface Generation) builds on this foundation
- **Template Engine:** Handlebars recommended for logic-less templates and TypeScript support
- **Performance:** Critical to cache compiled templates for repeated rendering
- **Flexibility:** Architecture should support both simple templates and complex code generation

---

**Story Created:** 2025-01-04
**Epic:** Epic 3: TypeScript Code Generation System
**Story Number:** 3.1
**Estimated Effort:** 6-8 hours
