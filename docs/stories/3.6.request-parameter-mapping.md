# Story 3.6: Request Parameter Mapping and Validation - Brownfield Addition

**Epic:** Epic 3: TypeScript Code Generation System

---

## User Story

**As a** generated MCP server,
**I want** to map MCP tool inputs to API request parameters with validation,
**So that** API calls are correctly formatted and valid.

---

## Story Context

**Existing System Integration:**

- Integrates with: Generator package from Stories 3.1-3.5, parser package from Epic 2
- Technology: TypeScript 5.x, template engine, parameter validation
- Follows pattern: Code generation pipeline, request mapping logic
- Touch points: Tool definitions from Story 3.5, HTTP client from Story 3.3, operations from Story 2.5

**Epic Context:**

This story implements the execute functions for MCP tools, mapping Claude's tool inputs to properly formatted API requests. After tool definitions are generated (Story 3.5), we need to implement the logic that transforms MCP tool arguments into HTTP requests with correct URLs, parameters, headers, and bodies.

**Project Context:**

Request parameter mapping is the translation layer between MCP tool invocations and API requests. It handles path parameter substitution, query parameter serialization, header construction, and request body formatting. For the Ozon Performance API with diverse parameter patterns across 300+ operations, accurate mapping is critical for API compatibility.

---

## Acceptance Criteria

### Functional Requirements

1. **Parameter Mapper Module Creation**
   - Create `packages/generator/src/parameter-mapper.ts` module
   - Export `generateParameterMapper(operation: OperationMetadata)` function
   - Function generates parameter mapping code for each operation
   - Support template-based code generation

2. **Tool Execute Function Implementation**
   - Update tools.ts template to include execute function logic
   - Each tool's execute function maps inputs to API request
   - Call HTTP client with mapped parameters
   - Return response from API
   - Type-safe with TypeScript generics

3. **Request Config Structure Generation**
   - Generate: `{ url, method, params, data, headers }` object
   - url: resolved path with substituted parameters
   - method: HTTP method (GET, POST, PUT, PATCH, DELETE)
   - params: query parameters object
   - data: request body object
   - headers: custom headers object

4. **Path Parameter Substitution**
   - Replace path templates with values: `/users/{userId}` + `{userId: 123}` → `/users/123`
   - Handle multiple path parameters: `/users/{userId}/posts/{postId}`
   - Validate all path parameters are provided
   - URL-encode parameter values
   - Handle special characters in parameters

5. **Query Parameter Mapping**
   - Map tool inputs to query parameters
   - Create `params` object for parameters with `in: 'query'`
   - Example: `{ page: 1, limit: 10 }` → `?page=1&limit=10`
   - Handle optional query parameters (exclude if not provided)
   - Preserve parameter order

6. **Header Parameter Mapping**
   - Map tool inputs to custom headers
   - Create `headers` object for parameters with `in: 'header'`
   - Exclude authentication headers (handled in Epic 4)
   - Preserve header name casing
   - Example: `{ 'X-Custom-Header': 'value' }`

7. **Request Body Mapping**
   - Map tool input `body` field to request data
   - Extract from tool arguments: `args.body`
   - Set as `data` in request config
   - Handle nested objects and arrays
   - Preserve JSON structure

8. **Parameter Validation**
   - Validate required parameters are present
   - Check parameter types match schema
   - Validate path parameters exist
   - Validate enum values if applicable
   - Throw clear error for missing/invalid parameters

9. **Type Coercion**
   - Convert string to number if schema specifies number
   - Convert string to boolean: `"true"` → `true`, `"false"` → `false`
   - Parse JSON strings for object/array parameters
   - Handle date-time strings (ISO 8601)
   - Preserve type safety with TypeScript

10. **Default Value Application**
    - Apply parameter defaults if not provided
    - Use OpenAPI default values
    - Example: `{ limit: 10 }` if limit not in args
    - Document defaults in generated code
    - Only apply to optional parameters

11. **Array Parameter Handling**
    - Serialize arrays per OpenAPI `style` parameter
    - Form style: `?tags=tag1&tags=tag2`
    - Space delimited: `?tags=tag1%20tag2`
    - Pipe delimited: `?tags=tag1|tag2`
    - Default to form style if not specified
    - Handle `explode` parameter

12. **Validation Error Messages**
    - Clear messages indicating missing parameters
    - Show expected type vs actual type
    - Include parameter name and location
    - Example: "Missing required parameter: userId (path)"
    - Example: "Invalid type for 'limit': expected number, got string"
    - Suggest fixes in error messages

### Integration Requirements

13. **Operation Metadata Integration**
    - Use operation metadata from Story 2.5
    - Extract parameter definitions for mapping
    - Handle all parameter locations (path, query, header, body)
    - Support all HTTP methods

14. **HTTP Client Integration**
    - Call HTTP client from Story 3.3
    - Use type-safe methods: `client.get<T>()`, `client.post<T>()`
    - Pass request config to client
    - Handle client errors appropriately

15. **Interface Integration**
    - Import types from Story 3.2
    - Type request bodies with generated interfaces
    - Type tool arguments with interfaces
    - Compile-time type checking

### Quality Requirements

16. **Testing Coverage**
    - Unit test: Path parameter substitution
    - Unit test: Multiple path parameters
    - Unit test: Query parameter mapping
    - Unit test: Header parameter mapping
    - Unit test: Request body mapping
    - Unit test: Required parameter validation
    - Unit test: Type coercion (string to number/boolean)
    - Unit test: Default value application
    - Unit test: Array parameter serialization (all styles)
    - Unit test: Validation error messages
    - Integration test: Full request mapping for various operations
    - Test coverage ≥80% for parameter mapping code

17. **Documentation Updates**
    - Document parameter mapping in generated README
    - Include examples of tool invocations
    - Document validation errors and fixes
    - Add troubleshooting section
    - Include parameter format examples

18. **Code Quality**
    - TypeScript strict mode compliance
    - Generated mapping code compiles without errors
    - ESLint checks pass for generated code
    - Prettier formatting applied
    - Parameter mapping <10ms per request

---

## Technical Notes

### Integration Approach

**Parameter Mapper Generator:**
```typescript
// packages/generator/src/parameter-mapper.ts
export function generateParameterMapping(
  operation: OperationMetadata
): string {
  const pathParams = operation.parameters.filter(p => p.in === 'path');
  const queryParams = operation.parameters.filter(p => p.in === 'query');
  const headerParams = operation.parameters.filter(p => p.in === 'header');
  const hasBody = operation.requestBody !== undefined;

  return `
    // Validate required parameters
    ${generateValidation(operation)}

    // Build request URL with path parameters
    let url = '${operation.path}';
    ${generatePathSubstitution(pathParams)}

    // Build query parameters
    const params: Record<string, any> = {};
    ${generateQueryMapping(queryParams)}

    // Build custom headers
    const headers: Record<string, string> = {};
    ${generateHeaderMapping(headerParams)}

    // Build request body
    ${hasBody ? 'const data = args.body;' : 'const data = undefined;'}

    // Execute request
    const response = await client.${operation.method}<any>(url, ${
      hasBody ? 'data, ' : ''
    }{ params, headers });

    return response;
  `;
}

function generatePathSubstitution(pathParams: ParameterMetadata[]): string {
  return pathParams.map(param => `
    if (!args.${param.name}) {
      throw new Error('Missing required path parameter: ${param.name}');
    }
    url = url.replace('{${param.name}}', encodeURIComponent(String(args.${param.name})));
  `).join('\n');
}

function generateQueryMapping(queryParams: ParameterMetadata[]): string {
  return queryParams.map(param => `
    if (args.${param.name} !== undefined) {
      params['${param.name}'] = args.${param.name};
    }${param.default ? ` else {
      params['${param.name}'] = ${JSON.stringify(param.default)};
    }` : ''}
  `).join('\n');
}

function generateHeaderMapping(headerParams: ParameterMetadata[]): string {
  return headerParams.map(param => `
    if (args.${param.name} !== undefined) {
      headers['${param.name}'] = String(args.${param.name});
    }
  `).join('\n');
}

function generateValidation(operation: OperationMetadata): string {
  const requiredParams = operation.parameters.filter(p => p.required);
  const hasRequiredBody = operation.requestBody?.required;

  const validations = requiredParams.map(param => `
    if (args.${param.name} === undefined) {
      throw new Error('Missing required parameter: ${param.name} (${param.in})');
    }
  `);

  if (hasRequiredBody) {
    validations.push(`
    if (!args.body) {
      throw new Error('Missing required request body');
    }
    `);
  }

  return validations.join('\n');
}
```

**Updated Tools Template:**
```typescript
{{!-- templates/mcp-server/src/tools.ts.hbs --}}
/**
 * MCP Tool Definitions for {{apiName}}
 * Generated at: {{generatedAt}}
 */

import { ApiClient } from './http-client.js';

export interface ToolDefinition {
  name: string;
  description: string;
  inputSchema: {
    type: 'object';
    properties: Record<string, any>;
    required?: string[];
  };
  execute: (client: ApiClient, args: any) => Promise<any>;
}

export const tools: ToolDefinition[] = [
{{#each tools}}
  {
    name: '{{name}}',
    description: '{{description}}',
    inputSchema: {{{json inputSchema}}},
    execute: async (client: ApiClient, args: any) => {
      {{{executeCode}}}
    }
  },
{{/each}}
];
```

**Example Generated Execute Function:**
```typescript
// Example: GET /users/{userId}?include=profile
execute: async (client: ApiClient, args: any) => {
  // Validate required parameters
  if (args.userId === undefined) {
    throw new Error('Missing required parameter: userId (path)');
  }

  // Build request URL with path parameters
  let url = '/users/{userId}';
  url = url.replace('{userId}', encodeURIComponent(String(args.userId)));

  // Build query parameters
  const params: Record<string, any> = {};
  if (args.include !== undefined) {
    params['include'] = args.include;
  }

  // Build custom headers
  const headers: Record<string, string> = {};

  // Execute request
  const response = await client.get<any>(url, { params, headers });

  return response;
}
```

**Example: POST with Body:**
```typescript
// Example: POST /users with body
execute: async (client: ApiClient, args: any) => {
  // Validate required parameters
  if (!args.body) {
    throw new Error('Missing required request body');
  }

  // Build request URL
  let url = '/users';

  // Build query parameters
  const params: Record<string, any> = {};

  // Build custom headers
  const headers: Record<string, string> = {};

  // Build request body
  const data = args.body;

  // Execute request
  const response = await client.post<any>(url, data, { params, headers });

  return response;
}
```

**Type Coercion Example:**
```typescript
// Example: Coerce string to number
if (args.limit !== undefined) {
  const limitValue = typeof args.limit === 'string'
    ? parseInt(args.limit, 10)
    : args.limit;

  if (isNaN(limitValue)) {
    throw new Error('Invalid type for limit: expected number');
  }

  params['limit'] = limitValue;
}
```

**CLI Integration:**
```typescript
// packages/cli/src/commands/generate.ts
import { parseOpenAPIDocument } from '@openapi-to-mcp/parser';
import { generateToolDefinitions } from '@openapi-to-mcp/generator';
import { generateParameterMapping } from '@openapi-to-mcp/generator';

async function generateCommand(openApiPath: string, options: Options) {
  const parseResult = await parseOpenAPIDocument(openApiPath);

  // Story 3.5: Generate tool definitions with execute stubs
  // Story 3.6: Generate parameter mapping for each tool
  logger.info('Generating tool implementations...');

  const toolsWithMapping = parseResult.operations.map(operation => ({
    ...operation,
    executeCode: generateParameterMapping(operation)
  }));

  const toolsCode = generateToolDefinitions(toolsWithMapping);
  await writeFile(path.join(options.output, 'src/tools.ts'), toolsCode);

  logger.info('✓ Tool implementations generated');

  // Continue with response processing (Story 3.7)...
}
```

### Existing Pattern Reference

- **Generator Architecture:** Story 3.1 template engine
- **Tool Definitions:** Story 3.5 tool structure
- **HTTP Client:** Story 3.3 for API requests
- **Operations:** Story 2.5 for parameter metadata

### Key Constraints

- **No Breaking Changes:** Must not modify Epic 1-2 or Stories 3.1-3.5
- **Performance:** Parameter mapping <10ms per request
- **Type Safety:** All generated code must be type-safe
- **Validation:** All required parameters validated
- **Error Messages:** Clear, actionable error messages

### Dependencies

**External Libraries:**
- None (uses native JavaScript/TypeScript)

**Internal Dependencies:**
- Story 3.1: Generator architecture
- Story 3.2: TypeScript interfaces
- Story 3.3: HTTP client
- Story 3.5: Tool definitions
- Story 2.5: Operation metadata
- Story 3.7: Will handle response processing

---

## Definition of Done

- [x] Functional requirements 1-12 met
- [x] Integration requirements 13-15 verified
- [x] Parameter mapper module created (`src/parameter-mapper.ts`)
- [x] `generateParameterMapping()` function implemented
- [x] Tool execute functions implemented (updated template)
- [x] Request config structure generation working
- [x] Path parameter substitution working
- [x] Query parameter mapping working
- [x] Header parameter mapping working
- [x] Request body mapping working
- [x] Parameter validation implemented
- [x] Type coercion working (string to number/boolean)
- [x] Default value application working
- [x] Array parameter handling (all styles)
- [x] Validation error messages clear and helpful
- [x] Operation metadata integration successful
- [x] HTTP client integration working
- [x] Interface integration successful (typed)
- [x] All tests pass (≥80% coverage)
- [x] Generated code compiles without errors
- [x] ESLint checks pass for generated code
- [x] Prettier formatting applied
- [x] Documentation complete (README, examples)
- [x] Performance validated (<10ms per request)
- [x] Tested with Ozon API operations (diverse parameter patterns)

---

## Risk and Compatibility Check

### Minimal Risk Assessment

**Primary Risk:** Complex parameter patterns or edge cases causing incorrect API requests

**Mitigation:**
- Comprehensive test suite with all parameter types
- Validate against real API specifications
- Test with Ozon API (300+ operations, diverse patterns)
- Clear error messages for debugging
- URL encoding for special characters

**Rollback:**
- Parameter mapping is code generation
- Can regenerate with different logic
- No state changes or permanent modifications

### Compatibility Verification

- [x] No breaking changes to existing APIs (Epic 1-2, Stories 3.1-3.5 unchanged)
- [x] Database changes: N/A (no database)
- [x] Generated code is valid TypeScript
- [x] Parameter mapping produces valid API requests
- [x] HTTP client methods used correctly

---

## Validation Checklist

### Scope Validation

- [x] Story can be completed in one development session (6-8 hours)
- [x] Integration approach is straightforward (code generation)
- [x] Follows existing patterns (generator, operations, HTTP client)
- [x] Implements execute functions for Story 3.5 tools

### Clarity Check

- [x] Story requirements are unambiguous
- [x] Integration points clearly specified (tools, HTTP client)
- [x] Success criteria are testable (API request correctness)
- [x] Parameter mapping rules explicitly defined

---

## Success Criteria

The story is successful when:

1. ✅ Parameter mapping code generated for all operations
2. ✅ Path parameters substituted correctly in URLs
3. ✅ Multiple path parameters handled
4. ✅ Query parameters mapped to params object
5. ✅ Header parameters mapped to headers object
6. ✅ Request bodies mapped to data object
7. ✅ Required parameters validated (throw errors if missing)
8. ✅ Type coercion works (string to number/boolean)
9. ✅ Default values applied to optional parameters
10. ✅ Array parameters serialized correctly (all styles)
11. ✅ Validation errors clear and actionable
12. ✅ URL encoding handles special characters
13. ✅ HTTP client called with correct request config
14. ✅ Generated code compiles without errors
15. ✅ Test coverage ≥80% with all tests passing
16. ✅ Performance target met (<10ms per request)
17. ✅ Tested with Ozon API operations successfully
18. ✅ Documentation complete
19. ✅ Ready for Story 3.7 to process responses

---

## Notes

- **Epic Sequence:** Story 3.6 builds on Stories 3.1-3.5 and precedes Story 3.7 (Response Processing)
- **Dependency:** Stories 3.1-3.5 must be complete before starting this story
- **Next Story:** Story 3.7 (Response Processing) will handle API response transformation
- **URL Encoding:** Critical for special characters in path/query parameters
- **Testing:** Focus on edge cases (missing params, type mismatches, special chars)
- **Performance:** Parameter mapping should be very fast (<10ms)
- **Validation:** Clear error messages help users debug tool invocations

---

**Story Created:** 2025-01-04
**Epic:** Epic 3: TypeScript Code Generation System
**Story Number:** 3.6
**Estimated Effort:** 6-8 hours
