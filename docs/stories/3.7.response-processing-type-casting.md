# Story 3.7: Response Processing and Type Casting - Brownfield Addition

**Epic:** Epic 3: TypeScript Code Generation System

---

## User Story

**As a** generated MCP server,
**I want** to process API responses and cast to TypeScript types,
**So that** data is properly typed and formatted for MCP responses.

---

## Story Context

**Existing System Integration:**

- Integrates with: Generator package from Stories 3.1-3.6, parser package from Epic 2
- Technology: TypeScript 5.x, template engine, response transformation
- Follows pattern: Code generation pipeline, type-safe response processing
- Touch points: HTTP client from Story 3.3, interfaces from Story 3.2, operations from Story 2.5

**Epic Context:**

This story implements response processing logic that transforms API responses into properly typed, formatted MCP responses. After requests are executed (Story 3.6), we need to handle responses - extracting data, applying type information, handling errors, and formatting for Claude's consumption.

**Project Context:**

Response processing is the final step in the request-response cycle. It ensures API responses are correctly typed with TypeScript interfaces, handles various response scenarios (success, error, different status codes), and formats data appropriately for MCP. For the Ozon Performance API with diverse response structures across 300+ operations, robust response handling is critical.

---

## Acceptance Criteria

### Functional Requirements

1. **Response Processor Module Creation**
   - Create `packages/generator/src/response-processor.ts` module
   - Export `generateResponseProcessing(operation: OperationMetadata)` function
   - Function generates response processing code for each operation
   - Support template-based code generation

2. **Response Schema Lookup**
   - Match HTTP status code to OpenAPI response schema
   - Handle: 200, 201, 204, 400, 401, 403, 404, 500, default
   - Use most specific match (e.g., 200 over 2xx over default)
   - Return schema name for type casting
   - Log warning if no schema defined for status code

3. **Type Casting to TypeScript Interfaces**
   - Cast response data to generated interface type
   - Example: `const data = response as UserResponse;`
   - Use interface from Story 3.2 generated types
   - Provide type safety for response data
   - Handle generic responses with `any` when schema unknown

4. **Success Response Handling (2xx)**
   - Detect status codes 200-299
   - Extract response data from HTTP client
   - Apply type casting with appropriate interface
   - Return formatted data for MCP response
   - Include metadata if configured (status, headers)

5. **Error Response Handling (4xx/5xx)**
   - Detect client errors (400-499) and server errors (500-599)
   - Extract error details from response
   - Format error for MCP: `{ error: true, message, code, details }`
   - Include status code and error type
   - Preserve original API error information

6. **Response Data Extraction**
   - Handle different content types: JSON, text, binary
   - JSON: parse and type-cast
   - Text: return as string
   - Binary: return base64 encoded or metadata
   - Default to JSON if content-type unclear

7. **Null/Undefined Handling**
   - Normalize missing fields per schema defaults
   - Handle nullable fields correctly
   - Example: `user.profile ?? null`
   - Preserve explicit nulls vs undefined
   - Document null handling behavior

8. **Array Response Formatting**
   - Handle large arrays with optional truncation
   - Option to limit array size for AI responses
   - Include total count if truncated
   - Example: `{ items: [...first 100], total: 1500, truncated: true }`
   - Configurable via environment variable

9. **Response Validation (Optional Strict Mode)**
   - Optionally validate response matches schema
   - Check required fields present
   - Validate field types
   - Throw validation error if mismatch
   - Configurable: strict mode on/off

10. **Error Context Enrichment**
    - Add operation context to errors
    - Include: operation name, request parameters, timestamp
    - Example: `{ error: true, operation: 'getUserById', params: {userId: 123}, timestamp: '...' }`
    - Preserve stack trace for debugging
    - Sanitize sensitive data from error context

11. **Response Metadata Inclusion**
    - Optionally include response metadata
    - Status code, headers (selected), response time
    - Example: `{ data: {...}, _meta: { status: 200, time: 150 } }`
    - Configurable via options
    - Useful for debugging and monitoring

12. **MCP Response Formatting**
    - Format final response for MCP protocol
    - Structure: `{ content: [{ type: 'text', text: JSON.stringify(data) }] }`
    - Pretty-print JSON for readability
    - Handle large responses (truncate if needed)
    - Include error flag for failures

### Integration Requirements

13. **Operation Metadata Integration**
    - Use operation response definitions from Story 2.5
    - Extract response schemas for each status code
    - Map schemas to generated interfaces from Story 3.2
    - Handle operations with multiple response types

14. **Interface Integration**
    - Import types from Story 3.2 generated interfaces
    - Type-cast response data with correct interface
    - Compile-time type checking for responses
    - Handle union types for multiple response schemas

15. **HTTP Client Integration**
    - Process responses from Story 3.3 HTTP client
    - Handle Axios response structure
    - Extract data from response.data
    - Process HTTP client errors (ApiError)

### Quality Requirements

16. **Testing Coverage**
    - Unit test: Success response (200) with type casting
    - Unit test: Created response (201) with data
    - Unit test: No content response (204)
    - Unit test: Client error (400, 404) formatting
    - Unit test: Server error (500) formatting
    - Unit test: Response data extraction (JSON, text)
    - Unit test: Null/undefined handling
    - Unit test: Array response truncation
    - Unit test: Error context enrichment
    - Unit test: MCP response formatting
    - Integration test: End-to-end response processing
    - Test coverage â‰¥80% for response processing code

17. **Documentation Updates**
    - Document response processing in generated README
    - Include error handling examples
    - Document configuration options (truncation, strict mode)
    - Add troubleshooting section for response issues
    - Include type casting examples

18. **Code Quality**
    - TypeScript strict mode compliance
    - Generated response code compiles without errors
    - ESLint checks pass for generated code
    - Prettier formatting applied
    - Response processing <5ms overhead

---

## Technical Notes

### Integration Approach

**Response Processor Generator:**
```typescript
// packages/generator/src/response-processor.ts
export function generateResponseProcessing(
  operation: OperationMetadata
): string {
  const successSchema = getSuccessResponseSchema(operation);
  const errorSchemas = getErrorResponseSchemas(operation);

  return `
    try {
      // Response received from HTTP client (Story 3.6 already executed request)
      // 'response' variable contains the API response

      // Type cast to appropriate interface
      ${successSchema ? `const typedData = response as ${successSchema.typeName};` : 'const typedData = response;'}

      // Format for MCP response
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(typedData, null, 2)
          }
        ]
      };
    } catch (error: any) {
      // Handle API errors
      throw {
        error: true,
        operation: '${operation.operationId}',
        message: error.message || 'Request failed',
        code: error.statusCode,
        details: error.response,
        timestamp: new Date().toISOString()
      };
    }
  `;
}

function getSuccessResponseSchema(operation: OperationMetadata): ResponseSchema | null {
  // Find 2xx response
  const successResponse = operation.responses.find(r =>
    r.statusCode.startsWith('2') || r.statusCode === 'default'
  );

  if (!successResponse?.schema) {
    return null;
  }

  return {
    statusCode: successResponse.statusCode,
    typeName: successResponse.schema, // Interface name from Story 3.2
    description: successResponse.description
  };
}
```

**Enhanced Execute Function Template:**
```typescript
{{!-- Updated templates/mcp-server/src/tools.ts.hbs --}}
export const tools: ToolDefinition[] = [
{{#each tools}}
  {
    name: '{{name}}',
    description: '{{description}}',
    inputSchema: {{{json inputSchema}}},
    execute: async (client: ApiClient, args: any) => {
      try {
        // Story 3.6: Parameter mapping and request execution
        {{{parameterMappingCode}}}

        // Story 3.7: Response processing and type casting
        {{{responseProcessingCode}}}

      } catch (error: any) {
        // Enhanced error handling
        const errorResponse = {
          error: true,
          operation: '{{name}}',
          message: error.message || 'Tool execution failed',
          code: error.statusCode,
          timestamp: new Date().toISOString()
        };

        if (error.response) {
          errorResponse.details = error.response;
        }

        throw errorResponse;
      }
    }
  },
{{/each}}
];
```

**Complete Execute Function Example:**
```typescript
// Example: GET /users/{userId}
execute: async (client: ApiClient, args: any) => {
  try {
    // Validate required parameters
    if (args.userId === undefined) {
      throw new Error('Missing required parameter: userId (path)');
    }

    // Build request URL with path parameters
    let url = '/users/{userId}';
    url = url.replace('{userId}', encodeURIComponent(String(args.userId)));

    // Build query parameters
    const params: Record<string, any> = {};

    // Execute request
    const response = await client.get<UserResponse>(url, { params });

    // Type cast response
    const typedData = response as UserResponse;

    // Format for MCP
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(typedData, null, 2)
        }
      ]
    };

  } catch (error: any) {
    // Enhanced error handling
    throw {
      error: true,
      operation: 'getUserById',
      message: error.message || 'Failed to get user',
      code: error.statusCode,
      details: error.response,
      timestamp: new Date().toISOString()
    };
  }
}
```

**Array Truncation Example:**
```typescript
// Optional array truncation for large responses
const MAX_ARRAY_SIZE = parseInt(process.env.MAX_RESPONSE_ARRAY_SIZE || '100');

function truncateArrays(data: any): any {
  if (Array.isArray(data)) {
    if (data.length > MAX_ARRAY_SIZE) {
      return {
        items: data.slice(0, MAX_ARRAY_SIZE),
        total: data.length,
        truncated: true,
        message: `Showing first ${MAX_ARRAY_SIZE} of ${data.length} items`
      };
    }
    return data;
  }

  if (typeof data === 'object' && data !== null) {
    const result: any = {};
    for (const [key, value] of Object.entries(data)) {
      result[key] = truncateArrays(value);
    }
    return result;
  }

  return data;
}
```

**Error Response Example:**
```typescript
// Example error response formatting
{
  error: true,
  operation: 'getUserById',
  message: 'User not found',
  code: 404,
  details: {
    error: 'NOT_FOUND',
    message: 'No user exists with ID: 12345'
  },
  timestamp: '2024-01-15T10:30:00.000Z'
}
```

**Type Import Example:**
```typescript
// Import generated interfaces for type casting
import type {
  UserResponse,
  CreateUserRequest,
  CreateUserResponse,
  ErrorResponse
} from './types.js';
```

**CLI Integration:**
```typescript
// packages/cli/src/commands/generate.ts
import { generateParameterMapping } from '@openapi-to-mcp/generator';
import { generateResponseProcessing } from '@openapi-to-mcp/generator';

async function generateCommand(openApiPath: string, options: Options) {
  const parseResult = await parseOpenAPIDocument(openApiPath);

  logger.info('Generating complete tool implementations...');

  const toolsWithImplementation = parseResult.operations.map(operation => ({
    name: operation.operationId,
    description: generateToolDescription(operation),
    inputSchema: generateInputSchema(operation),
    parameterMappingCode: generateParameterMapping(operation),
    responseProcessingCode: generateResponseProcessing(operation)
  }));

  const toolsCode = renderToolsTemplate(toolsWithImplementation);
  await writeFile(path.join(options.output, 'src/tools.ts'), toolsCode);

  logger.info('âœ“ Complete tool implementations generated');

  // Continue with project scaffolding (Story 3.8)...
}
```

### Existing Pattern Reference

- **Generator Architecture:** Story 3.1 template engine
- **Interfaces:** Story 3.2 for type casting
- **HTTP Client:** Story 3.3 response structure
- **Parameter Mapping:** Story 3.6 request execution
- **Operations:** Story 2.5 for response metadata

### Key Constraints

- **No Breaking Changes:** Must not modify Epic 1-2 or Stories 3.1-3.6
- **Performance:** Response processing <5ms overhead
- **Type Safety:** All responses properly typed
- **Error Handling:** All errors formatted consistently
- **MCP Compliance:** Response format follows MCP protocol

### Dependencies

**External Libraries:**
- None (uses native JavaScript/TypeScript)

**Internal Dependencies:**
- Story 3.1: Generator architecture
- Story 3.2: TypeScript interfaces for type casting
- Story 3.3: HTTP client response structure
- Story 3.6: Request execution (provides response)
- Story 2.5: Operation response metadata

---

## Definition of Done

- [x] Functional requirements 1-12 met
- [x] Integration requirements 13-15 verified
- [x] Response processor module created (`src/response-processor.ts`)
- [x] `generateResponseProcessing()` function implemented
- [x] Response schema lookup working
- [x] Type casting to TypeScript interfaces implemented
- [x] Success response handling (2xx) working
- [x] Error response handling (4xx/5xx) working
- [x] Response data extraction (JSON, text) working
- [x] Null/undefined handling implemented
- [x] Array response formatting (with truncation) working
- [x] Response validation (optional strict mode) implemented
- [x] Error context enrichment working
- [x] Response metadata inclusion (optional) working
- [x] MCP response formatting working
- [x] Operation metadata integration successful
- [x] Interface integration working (type casting)
- [x] HTTP client integration successful
- [x] All tests pass (â‰¥80% coverage)
- [x] Generated code compiles without errors
- [x] ESLint checks pass for generated code
- [x] Prettier formatting applied
- [x] Documentation complete (README, examples)
- [x] Performance validated (<5ms overhead)
- [x] Tested with Ozon API operations (diverse response types)

---

## Risk and Compatibility Check

### Minimal Risk Assessment

**Primary Risk:** Type casting mismatches or malformed responses causing runtime errors

**Mitigation:**
- Comprehensive test suite with various response types
- Optional strict mode for response validation
- Graceful fallback to `any` type when schema unknown
- Clear error messages for type mismatches
- Test with real Ozon API responses

**Rollback:**
- Response processing is code generation
- Can regenerate with different logic
- No state changes or permanent modifications

### Compatibility Verification

- [x] No breaking changes to existing APIs (Epic 1-2, Stories 3.1-3.6 unchanged)
- [x] Database changes: N/A (no database)
- [x] Generated code is valid TypeScript
- [x] Type casting uses Story 3.2 interfaces correctly
- [x] MCP response format compliant

---

## Validation Checklist

### Scope Validation

- [x] Story can be completed in one development session (6-8 hours)
- [x] Integration approach is straightforward (code generation)
- [x] Follows existing patterns (generator, interfaces, HTTP client)
- [x] Completes tool implementation started in Stories 3.5-3.6

### Clarity Check

- [x] Story requirements are unambiguous
- [x] Integration points clearly specified (interfaces, HTTP client)
- [x] Success criteria are testable (type safety, response format)
- [x] Response processing rules explicitly defined

---

## Success Criteria

The story is successful when:

1. âœ… Response processing code generated for all operations
2. âœ… Response schema lookup finds correct interface
3. âœ… Type casting applies appropriate TypeScript interface
4. âœ… Success responses (2xx) formatted correctly
5. âœ… Error responses (4xx/5xx) formatted with details
6. âœ… Response data extracted (JSON, text) correctly
7. âœ… Null/undefined values handled properly
8. âœ… Array responses formatted (with optional truncation)
9. âœ… Response validation works in strict mode
10. âœ… Error context enriched with operation details
11. âœ… Response metadata included when configured
12. âœ… MCP response format correct
13. âœ… Generated code compiles without errors
14. âœ… Type safety verified (no `any` warnings)
15. âœ… Test coverage â‰¥80% with all tests passing
16. âœ… Performance target met (<5ms overhead)
17. âœ… Tested with Ozon API responses successfully
18. âœ… Documentation complete
19. âœ… Ready for Story 3.8 project scaffolding

---

## Notes

- **Epic Sequence:** Story 3.7 builds on Stories 3.1-3.6 and precedes Story 3.8 (Project Scaffolding)
- **Dependency:** Stories 3.1-3.6 must be complete before starting this story
- **Next Story:** Story 3.8 (Project Scaffolding) will create package.json, README, config files
- **Type Safety:** Critical to use correct interfaces from Story 3.2
- **Testing:** Focus on various response scenarios (success, errors, edge cases)
- **Performance:** Response processing should add minimal overhead
- **MCP Format:** Ensure all responses follow MCP protocol structure

---

**Story Created:** 2025-01-04
**Epic:** Epic 3: TypeScript Code Generation System
**Story Number:** 3.7
**Estimated Effort:** 6-8 hours
